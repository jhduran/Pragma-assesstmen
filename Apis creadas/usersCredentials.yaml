openapi: 3.0.1
info:
  title: BancolombiaPay Currency Exchange - Subscription Management
  version: 1.0.0
  description: >-
    Permite gestionar las acciones varias que se pueden realizar sobre la
    activación del abono automático de remesas a través del producto BALM
    asociado a la billetera digital
  x-ibm-name: bancolombiapay-currency-exchange-subscription-management
  contact:
    name: Developers Support
    email: soporteapisinternas@bancolombia.com.co
servers:
  - url: >-
      https://$(catalog.host)/v1/operations/product-specific/consumer-services/currency-exchange/bancolombiapay-currency-exchange/subscription-management
paths:
  /currencies-exchange/enrollment:
    post:
      operationId: enroll
      x-api-type: proxy-jwt
      summary: >-
        Realiza la suscripción del cliente al abono automático para la recepción
        de remesas en la billetera digital.
      description: >
        ### Clasificación de la información: Público

        Realiza la suscripción del cliente al abono automático, para la
        recepción de remesas en la billetera digital. En algunos casos se
        actualiza datos adicionales del cliente, cuando este pertence al
        segmento social
        
      parameters:
        - $ref: "#/components/parameters/json-web-token"
        - $ref: "#/components/parameters/x-client-certificate"
        - $ref: "#/components/parameters/authorization"
        - $ref: "#/components/parameters/ip"
        - $ref: "#/components/parameters/device-id"
        - $ref: "#/components/parameters/strong-authentication"
        - $ref: "#/components/parameters/accept"
        - $ref: "#/components/parameters/message-id"

      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/enrollRequest'
            examples:
              Suscripción realizada:
                description: 
                  <b>Dado:</b> Que se cumplen todas las condiciones, se entrega la información adicional requerida y se envían los datos correctos.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se genera la inscripción al abono automático<p>
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
              Suscripción Sin Información Adicional:
                description: 
                  <b>Dado:</b> Que se cumplen todas las condiciones, se envían los datos correctos y no se requiere información adicional.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se genera la inscripción al abono automático<p> 
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    currencyExchangeSubscription:
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                    exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                        
              Faltan_parámetros_obligatorios:
                description: 
                  <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se recibe un mensaje de excepción<p>      
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: ''
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0

              Código de actividad económica no válido:
                description: 
                  <b>Dado:</b> Que se recibe un código de actividad económica no válido.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se recibe un mensaje de excepción<p>       
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: 'enfermero'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                        
              Confirmación de paso no válido:
                description: 
                  <b>Dado:</b> Que se recibe un confirmId que no corresponde al paso en ejecución o no es válido.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se recibe un mensaje de excepción<p>       
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of

              Comercio no se encuentra registrado:
                description: 
                  <b>Dado:</b> Que se envía un código relationshipt de un comercio no registrado.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se recibe un mensaje de excepción<p>              
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE50520
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0

              Identificador de relación cliente-comercio vencido:
                description: 
                    <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>    
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F933826EE50520
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: '00010'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of

              Actividad económica de riesgo alto:
                description: 
                    <b>Dado:</b> Que el cliente realiza una actividad económica que es considerada de riesgo alto.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>    
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F033826EE50520
                    currencyExchangeSubscription:
                      additionalInformation:
                        addressInformation:
                          stateCode: '05'
                          cityCode: '05001'
                          address: 'Carrera 25 #58-66'
                        financialInformation:
                          economicActivityCode: '0722'
                          monthlyExpenses: 1800000
                          monthlyIncome: 1800000
                      exchangeNumeral:
                        numeralCode: 1706
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of
        required: true
      responses:
        '200':
          x-success-response: Successfull
          description: Respuesta exitosa
          x-ibm-languages:
            description:
              en: Successful response.          
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/enrollResponse'
              examples:
                Suscripción realizada:
                  description: 
                    <b>Dado:</b> Que se cumplen todas las condiciones, se entrega la información adicional requerida (cuando aplica) y se envían los datos correctos.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se genera la inscripción al abono automático<p>
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.779Z'
                        _applicationId: default
                        _messageId: dbff089d-292d-4894-b842-8e88c7003525
                      message: >-
                        La información de suscripción se ha enviado a su correo
                        electrónico
                Suscripción Sin Información Adicional:
                  description: 
                    <b>Dado:</b> Que se cumplen todas las condiciones, se envían los datos correctos y no se requiere información adicional.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se genera la inscripción al abono automático<p> 
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.779Z'
                        _applicationId: default
                        _messageId: dbff089d-292d-4894-b842-8e88c7003525
                      message: >-
                        La información de suscripción se ha enviado a su correo
                        electrónico
        '400':
          description: Bad request
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Faltan parámetros obligatorios:
                      description: 
                        <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                        <b>Cuando:</b> se consume el api<p>
                        <b>Entonces:</b> Se recibe un mensaje de excepción<p> 
                      value:
                        data:
                         meta:
                          _requestDateTime: '2024-01-26T14:52:09.779Z'
                          _applicationId: default
                          _messageId: dbff089d-292d-4894-b842-8e88c7003525
                         status: 400
                         title: Bad Resquest
                         errors:
                          - code: BP20252
                            detail: Faltan parámetros obligatorios (address)
                Código de actividad económica no válido:
                  description: 
                    <b>Dado:</b> Que se recibe un código de actividad económica no válido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 400
                     title: Bad Resquest
                     errors:
                      - code: BP20251
                        detail: Datos inválidos (economicActivityCode)
                            
          x-ibm-languages:
            description:
              en: Error in the request.
        '401':
          description: Credenciales incorrectas.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Confirmación de paso no válido:
                  description: 
                    <b>Dado:</b> Que se recibe un confirmId que no corresponde al paso en ejecución o no es válido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>       
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 401
                     title: Unauthorized (RFC 7235)
                     errors:
                      - code: BP20256
                        detail: Evento no autorizado
          x-ibm-languages:
            description:
              en: Incorrect credentials.
        '404':
          description: Recurso no encontrado.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Comercio no se encuentra registrado:
                  description: 
                    <b>Dado:</b> Que se envía un código relationshipt de un comercio no registrado.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>       
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 404
                     title: Not Found
                     errors:
                      - code: BP20250
                        detail: No se encontraron registros

          x-ibm-languages:
            description:
              en: Resource not found.
        '409':
          description: >
            El estado del recurso presenta conflictos con los datos de la solicitud.
            ### Códigos de error
            Listado de códigos de error
            | code    | detail                                                          |
            | ------- | --------------------------------------------------------------- |
            | BP20254 | Alguno de los datos no coincide, inténtalo nuevamente           |
            | BP20269 | Se requiere autenticación                                       | 
            | BP20275 | Suscripción ya realizada                                        | 
            | BP20276 | No es posible finalizar el proceso, comuníquese con Bancolombia | 

          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Identificador de relación cliente-comercio vencido:
                  description: 
                    <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b> Se recibe un mensaje de excepción<p>    
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 409
                     title: Conflict
                     errors:
                      - code: BP20269
                        detail: Se requiere autenticación
                        
                Actividad económica de riesgo alto:
                  description: 
                      <b>Dado:</b> Que el cliente realiza una actividad económica que es considerada de riesgo alto.<p>
                      <b>Cuando:</b> se consume el api<p>
                      <b>Entonces:</b> Se recibe un mensaje de excepción<p>
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 409
                     title: Conflict
                     errors:
                      - code: BP20276
                        detail: No es posible finalizar el proceso, comuníquese con Bancolombia                                                
          x-ibm-languages:
            description:
              en: Resource state has conflicts with data of the request.
        '500':
          description: Error interno del servidor.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 500
                title: Internal Server Error
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Internal server error.
        '502':
          description: Error en la respuesta del proveedor del servicio.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 502
                title: Bad Gateway
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Error in the service provider response.
        '503':
          description: Servicio no disponible.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 503
                title: Service Unavailable
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service unavailable.
        '504':
          description: Tiempo de respuesta del proveedor del servicio excedido.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 504
                title: Gateway Timeout
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service provider response time exceeded.
      security:
        - clientSecret: []
          clientId: []
      x-codegen-request-body-name: requestBody
      tags:
        - Subscription Management
  /currencies-exchange/register-acceptance-terms:
    post:
      operationId: registerAcceptanceTerms
      x-api-type: proxy
      summary: Registra la aceptación de términos realizada por el usuario
      description: >
        ### Clasificación de la información: Público

        Registra la aceptación de términos realizada por el usuario y genera los
        valores de los posibles motivos por los cuales el usuario desea
        suscribirse al abono automático, para solicitar al usuario la selección
        de uno de ellos en el momento de la suscripción
      parameters:
        - $ref: "#/components/parameters/authorization"
        - $ref: "#/components/parameters/ip"
        - $ref: "#/components/parameters/device-id"
        - $ref: "#/components/parameters/strong-authentication"
        - $ref: "#/components/parameters/accept"
        - $ref: "#/components/parameters/message-id"
            
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/registerAcceptanceTermsRequest'
            examples:
              Cláusulas, términos y condiciones aceptadas:
                description: 
                  <b>Dado:</b> Que el cliente acepta los términos y condiciones del abono automático así como las cláusulas para el tratamiento de datos.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se entrega la lista de motivos para la recepción de remesas y se informa si es requerida información adicional<p>
                value:
                   data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    termsConditionAccepted:
                      clausesCustomerAccepted:
                        acceptance: true
                        version: '1'
                      productTermsAccepted:
                        acceptance: true
                        version: '1'
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                        
              Cláusulas, términos y condiciones no aceptadas:
                description: 
                  <b>Dado:</b> Que el cliente no acepta los términos y condiciones del abono automático así como las cláusulas para el tratamiento de datos.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b> Se recibe un mensaje de excepción<p>
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    termsConditionAccepted:
                      clausesCustomerAccepted:
                        acceptance: false
                        version: '1'
                      productTermsAccepted:
                        acceptance: false
                        version: '1'
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                        
              Faltan parámetros obligatorios:
                description: 
                  <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>              
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    termsConditionAccepted:
                      clausesCustomerAccepted:
                        acceptance: 
                        version: '1'
                      productTermsAccepted:
                        acceptance: true
                        version: '1'
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0

              Versión de términos, condiciones o cláusulas no válida:
                description: 
                  <b>Dado:</b> Que se envía una versión de términos, condiciones o cláusulas que no corresponde.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>               
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    termsConditionAccepted:
                      clausesCustomerAccepted:
                        acceptance: true
                        version: '30'
                      productTermsAccepted:
                        acceptance: true
                        version: '1'
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0

              identificador de relación cliente-comercio vencido:
                description: 
                  <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>              
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F933826EE5052
                    termsConditionAccepted:
                      clausesCustomerAccepted:
                        acceptance: true
                        version: '1'
                      productTermsAccepted:
                        acceptance: true
                        version: '1'
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
        required: true
      responses:
        '200':
          x-success-response: Successfull
          description: Respuesta exitosa
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/registerAcceptanceTermsResponse'
              examples:
                Cláusulas, términos y condiciones aceptada:
                  description: 
                   <b>Dado:</b> Que el cliente acepta los términos y condiciones del abono automático así como las cláusulas para el tratamiento de datos.<p>
                   <b>Cuando:</b> se consume el api<p>
                   <b>Entonces:</b> Se entrega la lista de motivos para la recepción de remesas y se informa si es requerida información adicional<p>
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.795Z'
                        _applicationId: default
                        _messageId: daaf5d3e-2ec3-400f-9bc5-51971c45e5cf        
                      security:
                        confirmId: >-
                          yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                      exchangeNumerals:
                        - numeralCode: 1706
                          maximumNumber: 150
                          description: >-
                            Viajes de negocios, gastos educativos, pagos
                            laborales a residentes, seguridad social.
                      requiredAdditionalInformation: false
          x-ibm-languages:
            description:
              en: Successful response.
        '400':
          description: Bad request
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Faltan parámetros obligatorios:
                  description: 
                    <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>              
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 400
                     title: Bad Resquest
                     errors:
                      - code: BP20252
                        detail: Faltan parámetros obligatorios (acceptance)
          x-ibm-languages:
            description:
              en: Error in the request.
        '401':
          description: Credenciales incorrectas.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:  
                Cláusulas, términos y condiciones no aceptadas:
                  description: 
                    <b>Dado:</b> Que el cliente no acepta los términos y condiciones del abono automático así como las cláusulas para el tratamiento de datos.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>
                  value:
                      data:
                       meta:
                        _requestDateTime: '2024-01-26T14:52:09.779Z'
                        _applicationId: default
                        _messageId: dbff089d-292d-4894-b842-8e88c7003525
                        status: 401
                       title: Unauthorized (RFC 7235)
                       errors:
                       - code: BP20256
                         detail: Evento no autorizado (acceptance=false)
          x-ibm-languages:
            description:
              en: Incorrect credentials.
        '404':
          description: Recurso no encontrado.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Versión de términos, condiciones o cláusulas no válida:
                  description: 
                    <b>Dado:</b> Que se envía una versión de términos, condiciones o cláusulas que no corresponde.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>             
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 404
                     title: Not Found
                     errors:
                      - code: BP20250
                        detail: No se encontraron registros (version)
          x-ibm-languages:
            description:
              en: Resource not found.
        '409':
          description: >
            El estado del recurso presenta conflictos con los datos de la solicitud.
            ### Códigos de error
            Listado de códigos de error
            | code    | detail                                                |
            | ------- | ------------------------------------------------------|
            | BP20254 | Alguno de los datos no coincide, inténtalo nuevamente |
            | BP20258 | El evento no pudo ser notificado exitosamente         |
            | BP20269 | Se requiere autenticación                             | 
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                identificador de relación cliente-comercio vencido:
                  description: 
                    <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>       
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 409
                     title: Conflict
                     errors:
                      - code: BP20269
                        detail: Se requiere autenticación
          x-ibm-languages:
            description:
              en: Resource state has conflicts with data of the request.
        '500':
          description: Error interno del servidor.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 500
                title: Internal Server Error
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Internal server error.
        '502':
          description: Error en la respuesta del proveedor del servicio.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 502
                title: Bad Gateway
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Error in the service provider response.
        '503':
          description: Servicio no disponible.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 503
                title: Service Unavailable
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service unavailable.
        '504':
          description: Tiempo de respuesta del proveedor del servicio excedido.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 504
                title: Gateway Timeout
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service provider response time exceeded.
      security:
        - clientSecret: []
          clientId: []
      x-codegen-request-body-name: requestBody
      tags:
        - Subscription Management
  /currencies-exchange/retrieve-terms-conditions:
    post:
      operationId: retrieveTermsConditions
      x-api-type: proxy
      summary: >-
        Genera ruta para la descarga de los archivos PDFs de términos y
        condiciones y las cláusulas para tratamiento de datos
      description: >
        ### Clasificación de la información: Público

        Genera las url´s de las rutas donde se encuentra el archivo PDF de
        términos y condiciones asociados a la activación del abono automático de
        remesas, así como también el PDF que contiene las cláusulas de
        autorización para el tratamiento de datos del cliente

      parameters:
        - $ref: "#/components/parameters/authorization"
        - $ref: "#/components/parameters/ip"
        - $ref: "#/components/parameters/device-id"
        - $ref: "#/components/parameters/strong-authentication"
        - $ref: "#/components/parameters/accept"
        - $ref: "#/components/parameters/message-id"
            
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/retrieveTermsConditionsRequest'
            examples:
              Ruta de cláusulas, términos y condiciones entregada, cliente nuevo:
                description: 
                  <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y el cliente es nuevo para esta funcionalidad<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se entrega la URL de la ruta de ubicación de cada uno de los archivos<p>    
                value:
                   data:
                     customer:
                       identification:
                         relationshipId: F1E4F933826EE5FF33
                     security:
                       confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
              Ruta de cláusulas, términos y condiciones entregada, cliente existe:
                description: 
                  <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y el cliente posee otro producto inscrito<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se entrega la URL de la ruta de ubicación de cada uno de los archivos<p>
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF55
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0   
              Faltan parámetros obligatorios:
                description: 
                  <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF33
                    security:
                      confirmId: >-
                      
              Confirmación de paso no válido:
                description: 
                  <b>Dado:</b> Que se recibe un confirmId que no corresponde al paso en ejecución o no es válido.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE5FF65
                    security:
                      confirmId: >-
                        paso siguiente      
              Ruta de archivos de cláusulas, términos y condiciones no encontrada:
                description: 
                  <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y no se encuentra la ruta de los archivos.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE50520
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0     

              Cliente no cumple condiciones:
                description: 
                  <b>Dado:</b> Que el cliente no supera alguna de las validaciones internas o presenta una condición que inhabilita la suscripción al abono automático.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>              
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F033826EE50520
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0     
              Cliente ya suscrito al abono automático:
                description: 
                  <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y no se encuentra la ruta de los archivos.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>           
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F033826EE50525
                    security:
                      confirmId: >-
                        yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0                           
        required: true
      responses:
        '200':
          x-success-response: Successfull
          description: Respuesta exitosa
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/retrieveTermsConditionsResponse'
              examples:
                Ruta de cláusulas, términos y condiciones entregada, cliente nuevo:
                  description: 
                    <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y el cliente es nuevo para esta funcionalidad<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se entrega la URL de la ruta de ubicación de cada uno de los archivos<p>    
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.808Z'
                        _applicationId: default
                        _messageId: 7256133c-9a8c-417f-b2c5-9dcb3c7ed5d7
                      termsCondition:
                        clausesCustomer:
                          version: '1'
                          url: https://local-bucket.amazonaws.com/uploads/terms.pdf
                        productTerms:
                          version: '1'
                          url: https://local-bucket.amazonaws.com/uploads/terms.pdf
                      security:
                        confirmId: >-
                          yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                      requiredSubscriptionUpdate: false

                Ruta de cláusulas, términos y condiciones entregada, cliente existe:
                  description: 
                    <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y el cliente posee otro producto inscrito<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se entrega la URL de la ruta de ubicación de cada uno de los archivos<p>
                  value:
                    data:
                       meta:
                        _requestDateTime: '2024-01-26T14:52:09.808Z'
                        _applicationId: default
                        _messageId: 7256133c-9a8c-417f-b2c5-9dcb3c7ed5d7
                       termsCondition:
                          clausesCustomer:
                            version: '1'
                            url: https://local-bucket.amazonaws.com/uploads/terms.pdf
                          productTerms:
                            version: '1'
                            url: https://local-bucket.amazonaws.com/uploads/terms.pdf
                       security:
                          confirmId: >-
                              yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
                       requiredSubscriptionUpdate: true          

          x-ibm-languages:
            description:
              en: Successful response.
        '400':
          description: Bad request
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Faltan parámetros obligatorios:
                  description: 
                    <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 400
                     title: Bad Resquest
                     errors:
                      - code: BP20252
                        detail: Faltan parámetros obligatorios (confirmId)
          x-ibm-languages:
            description:
              en: Error in the request.
        '401':
          description: Credenciales incorrectas.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Confirmación de paso no válido:
                  description: 
                    <b>Dado:</b> Que se recibe un confirmId que no corresponde al paso en ejecución o no es válido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.779Z'
                        _applicationId: default
                        _messageId: dbff089d-292d-4894-b842-8e88c7003525
                      status: 401
                      title: Unauthorized (RFC 7235)
                      errors:
                        - code: BP20256
                          detail: Evento no autorizado
          x-ibm-languages:
            description:
              en: Incorrect credentials.
        '404':
          description: Recurso no encontrado.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Ruta de archivos de cláusulas, términos y condiciones no encontrada:
                  description: 
                    <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y no se encuentra la ruta de los archivos.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>    
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 404
                     title: Not Found
                     errors:
                      - code: BP20250
                        detail: No se encontraron registros
          x-ibm-languages:
            description:
              en: Resource not found.
        '409':
          description: >
            El estado del recurso presenta conflictos con los datos de la
            solicitud.
            Listado de códigos de error
            | code    | detail                                                          |
            | ------- | --------------------------------------------------------------- |
            | BP20254 | Alguno de los datos no coincide, inténtalo nuevamente           |
            | BP20258 | El evento no pudo ser notificado exitosamente                   |
            | BP20269 | Se requiere autenticación                                       | 
            | BP20275 | Suscripción ya realizada                                        | 
            | BP20276 | No es posible finalizar el proceso, comuníquese con Bancolombia | 
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Cliente no cumple condiciones:
                  description: 
                    <b>Dado:</b> Que el cliente no supera alguna de las validaciones internas o presenta una condición que inhabilita la suscripción al abono automático.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>         
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 409
                     title: Conflict
                     errors:
                      - code: BP20276
                        detail: No es posible finalizar el proceso, comuníquese con Bancolombia
                        
                Cliente ya suscrito al abono automático:
                  description: 
                    <b>Dado:</b> Que se consultan la ruta de las cláusulas, los términos y condiciones para la suscripción al abono automático y no se encuentra la ruta de los archivos.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>         
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 409
                     title: Conflict
                     errors:
                      - code: BP20275
                        detail: Suscripción ya realizada                     
                        
          x-ibm-languages:
            description:
              en: Resource state has conflicts with data of the request.
        '500':
          description: Error interno del servidor.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 500
                title: Internal Server Error
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Internal server error.
        '502':
          description: Error en la respuesta del proveedor del servicio.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 502
                title: Bad Gateway
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Error in the service provider response.
        '503':
          description: Servicio no disponible.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 503
                title: Service Unavailable
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service unavailable.
        '504':
          description: Tiempo de respuesta del proveedor del servicio excedido.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 504
                title: Gateway Timeout
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service provider response time exceeded.
      security:
        - clientSecret: []
          clientId: []
      x-codegen-request-body-name: requestBody
      tags:
        - Subscription Management
  /currencies-exchange/subscription-information:
    post:
      operationId: retrieveDetailsSubscription
      x-api-type: proxy
      summary: >-
        Permite enviar vía correo la información del detalle de la suscripción
        al abono automático para la recepción de remesas
      description: >
        ### Clasificación de la información: Público

        Permite enviar vía correo la información del detalle de los datos de la
        suscripción del cliente al abono automático para la recepción de remesas
      parameters:
        - $ref: "#/components/parameters/authorization"
        - $ref: "#/components/parameters/ip"
        - $ref: "#/components/parameters/device-id"
        - $ref: "#/components/parameters/strong-authentication"
        - $ref: "#/components/parameters/accept"
        - $ref: "#/components/parameters/message-id"
        
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/retrieveDetailsSubscriptionRequest'
            examples:
              Información de suscripción enviada:
                description: 
                  <b>Dado:</b> Que se cumplen todas las condiciones, se envía un relationShipId válido para la consulta de los datos de suscripción.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se genera el correo de notificación con la información de los datos de suscripción al abono automático<p>         
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: AAE4F033826EE50525
              Faltan parámetros obligatorios:
                description:               
                  <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p> 
                value:
                  data:
                    customer:
                      identification:
                        relationshipId:
              El cliente no se encuentra registrado al abono automático:
                description:          
                  <b>Dado:</b> Que se envía un relationshipt de un cliente que no se encuentra suscripto al abono automático.<p>
                  <b>Cuando:</b> se consume el api<p>
                  <b>Entonces:</b>Se recibe un mensaje de excepción<p>               
                value:
                  data:
                    customer:
                      identification:
                        relationshipId: F1E4F933826EE50520
              Identificador de relación cliente-comercio vencido:
                  description:                      
                    <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>        
                  value:
                    data:
                      customer:
                        identification:
                          relationshipId: AAE4F933826EE50520

        required: true
      responses:
        '200':
          x-success-response: Successfull
          description: Respuesta exitosa
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/retrieveDetailsSubscriptionResponse'
              examples:
                Información de suscripción enviada:
                  description: 
                    <b>Dado:</b> Que se cumplen todas las condiciones, se envía un relationShipId válido para la consulta de los datos de suscripción.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se genera el correo de notificación con la información de los datos de suscripción al abono automático<p>         
                  value:
                    data:
                      meta:
                        _requestDateTime: '2024-01-26T14:52:09.813Z'
                        _applicationId: default
                        _messageId: e678fdfd-f95b-406a-8878-6a5309f8cd5c
                      message: >-
                          La información de suscripción se ha enviado a su correo
                          electrónico
          x-ibm-languages:
            description:
              en: Successful response.
        '400':
          description: Bad request
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Faltan parámetros obligatorios:
                  description:               
                    <b>Dado:</b> Que no se envian todos los datos obligatorios.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 400
                     title: Bad Resquest
                     errors:
                      - code: BP20252
                        detail: Faltan parámetros obligatorios (relationshipId)
          x-ibm-languages:
            description:
              en: Error in the request.
        '401':
          description: Credenciales incorrectas.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 401
                title: Unauthorized
                errors:
                  - code: BP20256
                    detail: Evento no autorizado
          x-ibm-languages:
            description:
              en: Incorrect credentials.
        '404':
          description: Recurso no encontrado.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                El cliente no se encuentra registrado al abono automático:
                  description:               
                    <b>Dado:</b> Que se envía un relationshipt de un cliente que no se encuentra suscripto al abono automático.<p>
                    <b>Cuando:</b> se consume el api<p>
                    <b>Entonces:</b>Se recibe un mensaje de excepción<p>       
                  value:
                    data:
                     meta:
                      _requestDateTime: '2024-01-26T14:52:09.779Z'
                      _applicationId: default
                      _messageId: dbff089d-292d-4894-b842-8e88c7003525
                     status: 404
                     title: Not Found
                     errors:
                      - code: BP20250
                        detail: No se encontraron registros
          x-ibm-languages:
            description:
              en: Resource not found.
        '409':
          description: >
            El estado del recurso presenta conflictos con los datos de la
            solicitud.

            Listado de códigos de error
            | code    | detail                                                |
            | --------| ----------------------------------------------------- |
            | BP20254 | Alguno de los datos no coincide, inténtalo nuevamente |
            | BP20258 | El evento no pudo ser notificado exitosamente         |
            | BP20269 | Se requiere autenticación                             | 
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              examples:
                Identificador de relación cliente-comercio vencido:
                    description:                      
                      <b>Dado:</b> Que se recibe un relationShipId vencido.<p>
                      <b>Cuando:</b> se consume el api<p>
                      <b>Entonces:</b>Se recibe un mensaje de excepción<p>      
                    value:
                      data:
                       meta:
                        _requestDateTime: '2024-01-26T14:52:09.779Z'
                        _applicationId: default
                        _messageId: dbff089d-292d-4894-b842-8e88c7003525
                       status: 409
                       title: Conflict
                       errors:
                        - code: BP20269
                          detail: Se requiere autenticación
          x-ibm-languages:
            description:
              en: Resource state has conflicts with data of the request.
        '500':
          description: Error interno del servidor.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 500
                title: Internal Server Error
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Internal server error.
        '502':
          description: Error en la respuesta del proveedor del servicio.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 502
                title: Bad Gateway
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Error in the service provider response.
        '503':
          description: Servicio no disponible.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 503
                title: Service Unavailable
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service unavailable.
        '504':
          description: Tiempo de respuesta del proveedor del servicio excedido.
          headers:
            Message-Id: 
              $ref: '#/components/headers/Message-Id'
            RateLimit-Limit:
              $ref: '#/components/headers/RateLimit-Limit'
            Content-Type:
              $ref: '#/components/headers/Content-Type'
            API-Version:
              $ref: '#/components/headers/API-Version'
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorRS'
              example:
                meta:
                  _messageId: c4e6bd04-5149-11e7-b114-b2f933d5fe68
                  _requestDateTime: 2017-01-24T05:00:00.000Z
                  _applicationId: acxff62e-6f12-42de-9012-3e7304418abd
                status: 504
                title: Gateway Timeout
                errors:
                  - code: BP20257
                    detail: El evento no pudo ser realizado, intente nuevamente.
          x-ibm-languages:
            description:
              en: Service provider response time exceeded.
      security:
        - clientSecret: []
          clientId: []
      x-codegen-request-body-name: requestBody
      tags:
        - Subscription Management
  /health:
    head:
      summary: Metodo que indica el monitoreo del api
      operationId: healthOperation
      responses:
        '200':
          description: Respuesta exitosa.
          x-ibm-languages:
            description:
              en: Successful response.
      security:
        - clientId: []
          clientSecret: []
      tags:
        - Monitoring
        
        
components:

  headers:
    Message-Id:
      description: Identificador del mensaje o de correlación usado para la     trazabilidad de los llamados a las APIs.
      schema:
        type: string
        x-ibm-languages:
          description:
            en: >-
                  Message identifier or correlation identifier used for the
                  traceability of the API calls.
                  
    RateLimit-Limit:
      description: Limite de solicitudes por intervalo de tiempo
      schema:
        type: number
        x-ibm-languages:
          description:
            en: Resquest limit per time interval.
            
    Content-Type:
      description: 'Formato de mensajeria de la API. Ejemplo: application/json.'
      schema:
        type: string
        x-ibm-languages:
          description:
            en: 'API message format. Example: application/json.'
            
    API-Version:
      description: 'Version de la API. Ejemplo: 1.0.0.'
      schema:
        type: string
        x-ibm-languages:
          description:
            en: 'API Version. Example: 1.0.0.'
            
  parameters:            
            
    json-web-token:
      name: json-web-token
      in: header        
      required: true
      description: JWT generado por el consumidor
      schema:
        type: string
      example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
         
    x-client-certificate:
      name: x-client-certificate
      in: header            
      required: true
      description: Certificado configurado en el portal, codificado en Base64 sin saltos de linea
      schema:
        type: string
      example: -----BEGIN CERTIFICATE-----MIIDvjCCAqYCCQCa4y5+b3BvfTANBgkqhkiG9w0BAQsFADCBoDELMAkGA1UEBhMCQ08xEjAQBgNVBAgMCUFOVElPUVVJQTERMA8GA1UEBwwITUVERUxMSU4xGTAXBgNVBAoMEEJBTkNPTE9NQklBIFMuQS4xJjAkBgNVBAsMHVZJQ0VQUkVTSURFTkNJQSBERSBURUNOT0xPR0lBMScwJQYDVQQDDB5wcnVlYmFqd3QuYXBwcy5hbWJpZW50ZXNiYy5jb20wHhcNMjIwMjI0MjE1NTM1WhcNMjMwMjI0MjE1NTM1WjCBoDELMAkGA1UEBhMCQ08xEjAQBgNVBAgMCUFOVElPUVVJQTERMA8GA1UEBwwITUVERUxMSU4xGTAXBgNVBAoMEEJBTkNPTE9NQklBIFMuQS4xJjAkBgNVBAsMHVZJQ0VQUkVTSURFTkNJQSBERSBURUNOT0xPR0lBMScwJQYDVQQDDB5wcnVlYmFqd3QuYXBwcy5hbWJpZW50ZXNiYy5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK-----END CERTIFICATE-----     
            
    strong-authentication:
      name: strong-authentication
      in: header
      required: true
      description: >-
        Confirmación del tercero de que el cliente pasó por un método de
        autenticación fuerte dentro de su aplicación
      schema:
        type: boolean
            
    authorization:
      name: authorization
      in: header
      required: true
      description: >-
        Credenciales de la aplicación, autenticación Basic
      schema:
        type: string
      example: Bearer AAIgZGZmMjE4MTY0MmNiN2VmMWU3YWE4ZGEwOTMyZDg3Nzl1UCIm6i0O-6D-0AEjCFwYMhiIMUoqVtp5dKVVif_EOeoHYhXbujxMXJ-8SIp7lRcoPMcx0VTOJzoQdSzVB5r7uoxdIe9fN3hnhi_NxaJIHug6t3GlyzIhLIwJ5la81agoyFOzne2GOfuo7aZucM3C
            
    ip:
      name: ip
      in: header
      required: true
      description: Ip del dispositivo desde el cual se realiza la transacción      
      schema:
        type: string
      example: 192.192.24.25
      
    device-id:
      name: device-id
      in: header
      required: true
      description: >-
        identificacion del Dispositivo desde donde se realiza la
        transacción. es el identificador unico del dispositivo que el
        cliente utiliza para hacer la transacción.
      schema:
        type: string
      example: b8:94:a5:ca:fc:22
      
    accept:
      name: accept
      in: header
      required: true
      description: application/json, el cual representa el formato de mensajería.
      schema:
        type: string
      example: application/vnd.bancolombia.v4+json
      
    message-id:
      name: message-id
      in: header
      required: true
      description: >-
            Identificador de transacción. Se recomienda usar un UUID para el
            valor de este campo.
      schema:
        type: string
        format: uuid
        pattern: >-
                ^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$
      example: 693f1c36-d4a2-4c57-aae6-0788dfab7c01

  schemas:    
    ErrorRS:
      description: Objeto que contiene la información del error
      type: object
      properties:
        status:
          allOf:
          - $ref: '#/components/schemas/basicErrorRS'
          - type: object
            properties:
              errors:
                $ref: '#/components/schemas/errors'

    basicErrorRS:
      type: object
      description: Estado de la respuesta
      required:
        - meta      
        - status
        - title
      additionalProperties: false
      properties:
        meta:
          $ref: '#/components/schemas/meta'      
        status:
          $ref: '#/components/schemas/status'
        title:
          $ref: '#/components/schemas/title'

    errors:
      type: array
      description: Lista de errores detectados.
      items:
        properties:
          code:
            $ref: '#/components/schemas/error'

    status:
      type: number
      description: >-
            Codigo de estado HTTP (status code) asociado al mensaje de error de
            la respuesta del llamado a la API.
      example: 404
    title:
      type: string
      description: >-
        Titulo asociado al codigo de estado HTTP (status code) asociado al
        mensaje de error de la respuesta del llamado a la API.
      example: Not Found

    error:
      required:
        - code
        - detail
      type: object
      properties:
        code:
          type: string
          description: An application-specific error code, expressed as a string value.
          example: BP404
        detail:
          type: string
          description: >-
            A human-readable explanation specific to this occurrence of the
            problem.
          example: Requested resource could not be found
  
    retrieveTermsConditionsRequest:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - customer
            - security
          properties:
            customer:
              $ref: '#/components/schemas/customer'
            security:
              $ref: '#/components/schemas/security'
    additionalInformation:
      type: object
      description: Información adicional para la inscripción al abono automático
      required:
        - addressInformation
        - financialInformation
      properties:
        addressInformation:
          $ref: '#/components/schemas/addressInformation'
        financialInformation:
          $ref: '#/components/schemas/financialInformation'
    addressInformation:
      type: object
      description: Información que relaciona la cuenta vinculada por el cliente
      required:
        - stateCode
        - cityCode
        - address
      properties:
        stateCode:
          type: string
          description: >-
            Código identificador del departamento geográfico según la DIAN, por
            ejemplo 05 que es el código asociado al departamento de Antioquia
          minLength: 1
          maxLength: 10
          example: '05'
        cityCode:
          type: string
          description: >-
            Código identificador de la ciudad según la DIAN, por ejemplo 05001
            que es el código asociado a la ciudad de Medellin
          minLength: 1
          maxLength: 10
          example: '05001'
        address:
          type: string
          description: Información de dirección donde reside el cliente
          minLength: 1
          maxLength: 60
          example: 'Carrera 25 #58-66'
    financialInformation:
      type: object
      description: Información de la actividad económica, ingresos y egresos del cliente
      required:
        - economicActivityCode
        - monthlyExpenses
        - monthlyIncome
      properties:
        economicActivityCode:
          type: string
          description: >-
            Coódigo de la actividad económica (código CIIU) que desempeña el
            cliente. Ejemplo 00010 que está asociado a las personas empleadas de
            una organización (ASALARIADOS)
          minLength: 1
          maxLength: 20
          example: '00010'
        monthlyExpenses:
          type: number
          format: double
          maximum: 9999999999999.99
          description: Información de gastos mensuales del cliente
          example: 1800000
        monthlyIncome:
          type: number
          format: double
          maximum: 9999999999999.99
          description: Información de ingresos mensuales del cliente
          example: 1800000
    registerAcceptanceTermsResponse:
      type: object
      required:
        - meta
        - data
      properties:
        meta:
          $ref: '#/components/schemas/meta'
        data:
          type: object
          required:
            - security
            - exchangeNumerals
            - requiredAdditionalInformation
          properties:
            security:
              $ref: '#/components/schemas/security'
            exchangeNumerals:
              $ref: '#/components/schemas/exchangeNumerals'
            requiredAdditionalInformation:
              type: boolean
              description: >-
                Este dato indica que se debe solicitar al cliente completar
                información de dirección, ingresos y egresos
              example: false
    clausesCustomerAccepted:
      type: object
      description: >-
        Información de de cláusulas de autorización de manejo de datos
        personales
      required:
        - version
        - acceptance
      properties:
        version:
          type: string
          description: >-
            versión de términos y condiciones aceptados para la suscripción al
            abono automático
          minLength: 1
          maxLength: 6
          example: '1'
        acceptance:
          type: boolean
          description: >-
            Indica si el cliente acepto las cláusulas para el tratamiento de
            datos personales
          example: true
    retrieveDetailsSubscriptionResponse:
      type: object
      required:
        - meta
        - data
      properties:
        meta:
          $ref: '#/components/schemas/meta'
        data:
          type: object
          required:
            - message
          properties:
            message:
              type: string
              description: >-
                Mensaje de confirmación de envío de información sobre la
                suscripción al abono automático
              minLength: 1
              maxLength: 150
              example: >-
                La información de suscripción se ha enviado a su correo
                electrónico
    exchangeNumeral:
      type: object
      description: Listado de motivos de recepción de remesas
      required:
        - numeralCode
      properties:
        numeralCode:
          type: integer
          format: int32
          minimum: 0
          maximum: 9999
          description: Coódigo del Numeral Cambiario
          example: 1706
    productTerms:
      type: object
      description: >-
        Información de términos y condiciones para la inscripción en el abono
        automático
      required:
        - url
        - version
      properties:
        url:
          type: string
          description: >-
            Ruta de la ubicación de los archivos de términos y condiciones para
            la inscripción en el abono automático
          minLength: 1
          maxLength: 200
          example: https://local-bucket.amazonaws.com/uploads/terms.pdf
        version:
          type: string
          description: >-
            Versión de términos y condiciones consultados  para la inscripción
            en el abono automático
          minLength: 1
          maxLength: 6
          example: '1'
    currencyExchangeSubscription:
      type: object
      description: Información de la suscripción al abono automático de remesas
      required:
        - exchangeNumeral
      properties:
        exchangeNumeral:
          $ref: '#/components/schemas/exchangeNumeral'
        additionalInformation:
          $ref: '#/components/schemas/additionalInformation'
    enrollRequest:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - customer
            - currencyExchangeSubscription
            - security
          properties:
            customer:
              $ref: '#/components/schemas/customer'
            currencyExchangeSubscription:
              $ref: '#/components/schemas/currencyExchangeSubscription'
            security:
              $ref: '#/components/schemas/security'
    security:
      type: object
      description: Información de indicador de enrolamiento
      required:
        - confirmId
      properties:
        confirmId:
          type: string
          description: Confirmación de paso ejecutado de validación de información
          minLength: 1
          maxLength: 2000
          example: >-
            yBLW1aVToelcK9EKH/OMzOx2L6ZG3iLIRFQRNgMZKJ8/eat3SDoN8vnIfCiQcodPNV+4tsc5XheD2KK+cbN4+a5eTiY2qNLc3Bg6ibjWitWUz1d6/c48t++khEmRSqn19DJB7aTnUb7ydECCki3YQkoO43t/2ujQWvTbkTIAopJzTjOOpqEbUdmLEoIEC0oVei8jtLhibiBaDJpSEcdvTGVd/bdsI9bpolBqHXD+mjjK9RBAkhhhr0UaMTB7305+vMsVyy/lXY3H9dqNWXAXxxmwx49tKBwyH+WMDGTolMwE0IDc/jWRFb+2LjPLfyd1dUtgb0YO3Rit2uWZ1L/Of//SlgeceNs0oYx9GfVCyl8zU3o6GxlawHPGRA1QwcrDo020PtLUx1OD33wCFzNYCCKsQ+OwX3nuFqU+dmPfTqnOrrg+fkKjltBjkjzudJpkHigEt79Kw080B1EdsX0
    clausesCustomer:
      type: object
      description: >-
        Información de de cláusulas de autorización de manejo de datos
        personales
      required:
        - url
        - version
      properties:
        url:
          type: string
          description: >-
            Ruta de la ubicación de los archivos de cláusulas de autorización de
            manejo de datos personales
          minLength: 1
          maxLength: 200
          example: https://local-bucket.amazonaws.com/uploads/terms.pdf
        version:
          type: string
          description: versión de cláusulas consultadas
          minLength: 1
          maxLength: 6
          example: '1'
    termsCondition:
      type: object
      description: Información de cláusulas, términos y condiciones
      required:
        - productTerms
        - clausesCustomer
      properties:
        productTerms:
          $ref: '#/components/schemas/productTerms'
        clausesCustomer:
          $ref: '#/components/schemas/clausesCustomer'
    identification:
      type: object
      description: Información que relaciona la cuenta vinculada por el cliente
      required:
        - relationshipId
      properties:
        relationshipId:
          type: string
          description: >-
            identificador de la relacion de autorizacion establecida entre el
            tercero y el cliente para el producto seleccionado
          minLength: 1
          maxLength: 33
          example: F1E4F933826EE5FF33
    termsConditionAccepted:
      type: object
      description: Información de cláusulas, términos y condiciones
      required:
        - productTermsAccepted
        - clausesCustomerAccepted
      properties:
        productTermsAccepted:
          $ref: '#/components/schemas/productTermsAccepted'
        clausesCustomerAccepted:
          $ref: '#/components/schemas/clausesCustomerAccepted'
    exchangeNumerals:
      type: array
      items:
        type: object
        required:
          - maximumNumber
          - numeralCode
          - description
        properties:
          maximumNumber:
            type: integer
            format: int32
            minimum: 0
            maximum: 99999
            description: Cantidad máxima de numerales cambiarios
            example: 150
          numeralCode:
            type: integer
            format: int32
            minimum: 0
            maximum: 9999
            description: Coódigo del Numeral Cambiario
            example: 1706
          description:
            type: string
            description: Descripción del Numeral Cambiario
            minLength: 1
            maxLength: 1000
            example: >-
              Viajes de negocios, gastos educativos, pagos laborales a
              residentes, seguridad social.
    enrollResponse:
      type: object
      required:
        - meta
        - data
      properties:
        meta:
          $ref: '#/components/schemas/meta'
        data:
          type: object
          required:
            - message
          properties:
            message:
              type: string
              description: Mensaje de confirmación de suscripción al abono automático
              minLength: 1
              maxLength: 150
              example: >-
                La información de suscripción se ha enviado a su correo
                electrónico
    productTermsAccepted:
      type: object
      description: >-
        Información de términos y condiciones para la inscripción en el abono
        automático
      required:
        - version
        - acceptance
      properties:
        version:
          type: string
          description: >-
            versión de términos y condiciones consultados para la suscripción al
            abono automático
          minLength: 1
          maxLength: 6
          example: '1'
        acceptance:
          type: boolean
          description: >-
            Indica si el cliente acepto los términos y condiciones del abono
            automático
          example: true
    retrieveDetailsSubscriptionRequest:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - customer
          properties:
            customer:
              $ref: '#/components/schemas/customer'
    customer:
      type: object
      description: Datos de identificación de la relación cliente-comercio
      required:
        - identification
      properties:
        identification:
          $ref: '#/components/schemas/identification'
    registerAcceptanceTermsRequest:
      type: object
      required:
        - data
      properties:
        data:
          type: object
          required:
            - customer
            - termsConditionAccepted
            - security
          properties:
            customer:
              $ref: '#/components/schemas/customer'
            termsConditionAccepted:
              $ref: '#/components/schemas/termsConditionAccepted'
            security:
              $ref: '#/components/schemas/security'
              
    retrieveTermsConditionsResponse:
      type: object
      required:
        - meta
        - data
      properties:
        meta:
          $ref: '#/components/schemas/meta'
        data:
          type: object
          required:
            - termsCondition
            - security
            - requiredSubscriptionUpdate
          properties:
            termsCondition:
              $ref: '#/components/schemas/termsCondition'
            security:
              $ref: '#/components/schemas/security'
            requiredSubscriptionUpdate:
              type: boolean
              description: >-
                Este dato indica que se debe solicitar al cliente la
                confirmación para cambiar la suscripción de abono automático con
                el producto de la billetera digital
              example: false
    meta:
      required:
        - _applicationId
        - _messageId
        - _requestDateTime
      type: object
      properties:
        _messageId:
          type: string
          format: uuid
          example: 56d6adc5-b25a-4d75-a663-56a62bad4982
        _requestDateTime:
          type: string
          format: date-time
          example: 2016-06-23T16:07:21.205Z
        _applicationId:
          type: string
          example: acxff62e-6f12-42de-9012-3e7304418abd
      description: Datos de trazabilidad e informacion técnica del mensaje.
      
  securitySchemes:
    clientId:
      type: apiKey
      in: header
      name: Client-Id
      x-key-type: client_id
    clientSecret:
      type: apiKey
      in: header
      name: Client-Secret
      x-key-type: client_secret
tags:
  - name: Monitoring
    description: Operaciones para realizar el monitoreo de la API
  - name: Subscription Management
    description: >-
      Permite gestionar las acciones varias que se pueden realizar sobre la
      activación del abono automático de remesas a través del producto BALM
      asociado a la billetera digital
x-ibm-configuration:
  compatibility:
    enforce-required-params: false
    request-headers: true
  testable: true
  enforced: true
  cors:
    enabled: true
  phase: realized
  properties:
    kid:
      description: ''
      encoded: false
    issuer:
      value: https://api-aws-dev.apps.ambientesbc.com/
      description: ''
      encoded: false
    expTime:
      description: Tiempo de expiración del JWT
    sub:
      value: api-connect-communication-management
      encoded: false
    tokenUse:
      value: access
      encoded: false
    clientId:
      value: api-connect-communication-management
      encoded: false
    scope:
      value: communication-management
      encoded: false
    endpoint:
      value: ''
      description: ''
      encoded: false
    tlsProfile:
      value: ''
      description: ''
      encoded: false
    catalogName:
      value: ''
      description: ''
      encoded: false
    hostName:
      value: ''
      description: ''
      encoded: false
  catalogs:
    Development:
      properties:
        expTime: '20'
        kid: gw-aws-ecosistemas-de-riesgos-jwt
        issuer: https://api-aws-dev.apps.ambientesbc.com
        tlsProfile: apic-tls-profile-aws-ecosistemas-de-riesgos-eks-jwt
        endpoint: https://esbdev.bancolombia.corp:3300/ESB/SOAP/Default
        hostName: http://bancolombia.com.co
        sub: api-connect-communication-management
        tokenUse: access
        clientId: api-connect-communication-management
        scope: communication-management
    Testing:
      properties:
        expTime: '19'
        kid: gw-aws-ecosistemas-de-riesgos-jwt-QA
        issuer: https://api-aws-dev.apps.ambientesbc.com
        tlsProfile: apic-tls-profile-aws-ecosistemas-de-riesgos-eks-jwt
        endpoint: https://esbdev.bancolombia.corp:3300/ESB/SOAP/Default
        hostName: http://bancolombia.com.co
        sub: api-connect-communication-management
        tokenUse: access
        clientId: api-connect-communication-management
        scope: communication-management
    Sandbox:
      properties:
        expTime: '5'
        kid: gw-aws-ecosistemas-de-riesgos-jwt-DEV
        issuer: https://api-aws-dev.apps.ambientesbc.com
        tlsProfile: apic-tls-profile-aws-ecosistemas-de-riesgos-eks-jwt
        endpoint: https://esbdev.bancolombia.corp:3300/ESB/SOAP/Default
        hostName: http://bancolombia.com.co
        sub: api-connect-communication-management
        tokenUse: access
        clientId: api-connect-communication-management
        scope: communication-management
    Production:
      properties:
        expTime: '1'
        kid: gw-aws-ecosistemas-de-riesgos-jwt-PDN
        issuer: https://api-aws-dev.apps.ambientesbc.com
        tlsProfile: apic-tls-profile-aws-ecosistemas-de-riesgos-eks-jwt
        endpoint: https://esbdev.bancolombia.corp:3300/ESB/SOAP/Default
        hostName: http://bancolombia.com.co
        sub: api-connect-communication-management
        tokenUse: access
        clientId: api-connect-communication-management
        scope: communication-management
  type: rest
  gateway: datapower-api-gateway
  activity-log:
    enabled: true
    success-content: payload
    error-content: payload
  assembly:
    execute:
      - switch:
          title: switch
          case:
            - condition: ($operationID() = 'enroll')
              execute:
                - gatewayscript:
                    title: validate-request
                    source: >-
                      const errors = [];      


                      validateParameters();
                            
                      function validateParameters() {
                        try {
                          const app = context.get('client.app.name').trim();
                          const consumerId = getConsumer(app);
                          context.set('ctx.consumer', consumerId);
                            
                          const requestHeaders = context.get('request.headers');
                          const headerConstraints = {"json-web-token":{"in":"header","name":"json-web-token","required":true,"type":"string"},"x-client-certificate":{"in":"header","name":"x-client-certificate","required":true,"type":"string"},"authorization":{"in":"header","name":"authorization","required":true,"type":"string"},"ip":{"in":"header","name":"ip","required":true,"type":"string"},"device-id":{"in":"header","name":"device-id","required":true,"type":"string"},"strong-authentication":{"in":"header","name":"strong-authentication","required":true,"type":"boolean"},"accept":{"in":"header","name":"accept","required":true,"type":"string"},"message-id":{"in":"header","name":"message-id","required":true,"type":"string","pattern":"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"}};
                          validateRequestHeaders(headerConstraints, requestHeaders);
                          const bodyConstraints = {"requestBody":{"type":"object","properties":{"data":{"type":"object","properties":{"customer":{"type":"object","properties":{"identification":{"type":"object","properties":{"relationshipId":{"type":"string","maxLength":33,"minLength":1}},"required":["relationshipId"]}},"required":["identification"]},"currencyExchangeSubscription":{"type":"object","properties":{"exchangeNumeral":{"type":"object","properties":{"numeralCode":{"type":"integer","format":"int32","maximum":9999,"minimum":0}},"required":["numeralCode"]},"additionalInformation":{"type":"object","properties":{"addressInformation":{"type":"object","properties":{"stateCode":{"type":"string","maxLength":10,"minLength":1},"cityCode":{"type":"string","maxLength":10,"minLength":1},"address":{"type":"string","maxLength":60,"minLength":1}},"required":["stateCode","cityCode","address"]},"financialInformation":{"type":"object","properties":{"economicActivityCode":{"type":"string","maxLength":20,"minLength":1},"monthlyExpenses":{"type":"number","format":"double","maximum":9999999999999.99},"monthlyIncome":{"type":"number","format":"double","maximum":9999999999999.99}},"required":["economicActivityCode","monthlyExpenses","monthlyIncome"]}},"required":["addressInformation","financialInformation"]}},"required":["exchangeNumeral"]},"security":{"type":"object","properties":{"confirmId":{"type":"string","maxLength":2000,"minLength":1}},"required":["confirmId"]}},"required":["customer","currencyExchangeSubscription","security"]}},"required":["data"]}};
                          const getRequestBody = new Promise((resolve, reject) => {
                            context.message.body.readAsJSON((error, json) => (error) ?
                              reject(error) :
                              resolve(json));
                          });

                          const requestBodyValidation = (requestBody) => {
                            validateTags(bodyConstraints, requestBody);
                            
                            if (errors.length > 0) {
                              context.set('ctx.errors', errors);
                              throwParameterError('ParametersException');
                            }
                          }

                          getRequestBody.then(requestBodyValidation, handleError);
                          

                          if (errors.length > 0) {
                            context.set('ctx.errors', errors);
                            throwParameterError('ParametersException');
                          }

                        } catch (e) {
                          handleError(e)
                        }
                      }
                              
                      function validateRequestHeaders(constraints,
                      requestHeaders) {
                          const constraintsTags = Object.entries(constraints);
                          const validation = (constraintsTags.map((constraint) => {
                            const [constraintName, constraintValue] = constraint;
                            const tagToValidate = Object.entries(requestHeaders)
                              .find(tag => tag[0].toUpperCase() === constraintName.toUpperCase());
                            if (!tagToValidate) {
                              const detail = `Parámetro ${constraintName} es requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                              return false;
                            }
                            return validatePrimitives(constraintValue, tagToValidate);
                          })).every(Boolean) ? true : false;
                          return validation;
                        }

                      function validateTags(constraints, request) {
                          let validation;
                          const tagConstraints = Object.entries(constraints);
                          const requestTagNames = Object.keys(request);

                          tagConstraints.forEach((tagConstraint) => {
                            const [tagConstraintName, tagConstraintValue] = tagConstraint;

                            if (tagConstraintValue.properties ||
                              (tagConstraintValue.items && tagConstraintValue.items.properties)) {
                              const { required, properties } = (tagConstraintValue.properties)
                                ? tagConstraintValue
                                : tagConstraintValue.items;

                              const validTagNames = Object.keys(properties);

                              if (required) {
                                validateRequiredTags(required, requestTagNames);
                              }

                              validation = (requestTagNames.map((requestTagName) => {
                                return validateTag(validTagNames, requestTagName, properties,
                                  request[requestTagName]);

                              })).every(Boolean) ? true : false;
                            } else {
                              if (tagConstraintValue.required && !requestTagNames.includes(tagConstraintName)) {
                                const detail = `Parámetro ${tagConstraintName} requerido.`;
                                const code = 'SA400';
                                errors.push({ code, detail });
                              } else {
                                const requestTagTovalidate = Object.entries(request)
                                  .filter((recuestField) => recuestField[0] === tagConstraintName);
                                if (requestTagTovalidate) {
                                  validation = validatePrimitives(
                                    constraints[tagConstraintName],
                                    requestTagTovalidate[0]
                                  );
                                }
                              }
                            }
                          });
                          return validation;
                        }

                      function validateTag(validTagNames, requestTagName,
                      constraints, requestObject) {
                          if (!validTagNames.includes(requestTagName)) {
                            const detail = `Parámetro ${requestTagName} no es un tag válido`;
                            const code = 'SA400';
                            errors.push({ code, detail });
                            return false;
                          }
                          const tagConstraint = {};
                          if (Array.isArray(requestObject)) {
                            if (typeof requestObject[0] !== 'object') {
                              return validatePrimitives(
                                constraints[requestTagName],
                                [requestTagName, requestObject]
                              );
                            }
                            return (requestObject.map((item) => {
                              tagConstraint[requestTagName] = constraints[requestTagName];
                              return validateTags(tagConstraint, item);
                            })).every(Boolean) ? true : false;
                          }

                          if (typeof requestObject !== 'object') {
                            return validatePrimitives(
                              constraints[requestTagName],
                              [requestTagName, requestObject]
                            );
                          }
                          tagConstraint[requestTagName] = constraints[requestTagName];
                          return validateTags(tagConstraint, requestObject);
                        }

                      function validateRequiredTags(requiredTags,
                      requestTagNames) {
                          requiredTags.forEach((requiredTag) => {
                            if (!requestTagNames.includes(requiredTag)) {
                              const detail = `Parámetro ${requiredTag} requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                            }
                          });
                        }

                      function validatePrimitives(constraint, entrie) {
                          const value = entrie[1];
                          const isArray = Array.isArray(value);
                          if (isArray) {
                            if (value.length < 1) {
                              const code = 'SA400';
                              const detail = `El arreglo ${entrie[0]} debe tener por lo mennos un valor`;
                              errors.push({ code, detail });
                              return false;
                            }
                            if (constraint.items.type === 'string') {
                              return validateStringArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'number') {
                              return validateNumberArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'integer') {
                              return validateIntegerArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'boolean') {
                              return validateBooleanArray(constraint.items, entrie);
                            }
                          }
                          if (constraint.type === 'string') {
                            return validateString(constraint, entrie);
                          }
                          if (constraint.type === 'number') {
                            return validateNumber(constraint, entrie);
                          }
                          if (constraint.type === 'integer') {
                            return validateInteger(constraint, entrie);
                          }
                          if (constraint.type === 'boolean') {
                            return validateBoolean(constraint, entrie);
                          }
                        }

                      function validateString(constraint, entrie) {
                          const code = 'SA400';
                          const type = 'string';
                          const [name, value] = entrie;
                          const { minLength, maxLength, pattern } = constraint;
                          const enumConstraints = constraint.enum;
                          const validPattern = (pattern) ? new RegExp(pattern) : null;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo ${type}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (validPattern && !validPattern.test(value)) {
                            const detail = `El valor del parámetro ${name} no cumple con la expresión regular`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (minLength && value.length < minLength) {
                            const detail = `Longitud del parámetro ${name} es menor a la lógitud mínima esperada: ${minLength}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (maxLength && value.length > maxLength) {
                            const detail = `Longitud del parámetro ${name} es mayor a la lógitud máxima esperada: ${maxLength}`;
                            errors.push({ code, detail });
                            return false;
                          }

                          return true;
                        }

                      function validateStringArray(constraint, tagToValidate) {
                          const [parameterName, arrayString] = tagToValidate;
                          return (arrayString.map(stringValue =>
                            validateString(constraint, [parameterName, stringValue])))
                            .every(Boolean) ? true : false;
                        }

                      function countDigits(number) {
                          const numberString = number.toString();
                          const [integers, decimals = ''] = numberString.split('.');
                          return { integers: integers.length, decimals: decimals.length };
                        }

                      function validateNumber(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo double`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          const { integers, decimals } = countDigits(value);
                          const { integers: expectedIntegers, decimals: expectedDecimals } = countDigits(maximum);
                          const expectedDigitsValidation = integers <= expectedIntegers && decimals <= expectedDecimals;
                          if (!expectedDigitsValidation) {
                            const detail = `El valor del parámetro ${name} espera máximo ${expectedIntegers} dígitos enteros y máximo ${expectedDecimals} dígitos decimales`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateNumberArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateNumber(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateInteger(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { minimum, maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo integer`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value < minimum) {
                            const detail = `El valor del parámetro ${name} es menor que el valor permitido: ${minimum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value > maximum) {
                            const detail = `El valor del parámetro ${name} es mayor que el valor permitido: ${maximum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateIntegerArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateInteger(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateBoolean(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { type } = constraint;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo boolean`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateBooleanArray(constraint, tagToValidate) {
                          const [parameterName, arrayBoolean] = tagToValidate;
                          return (arrayBoolean.map(booleanValue => validateBoolean(constraint, [parameterName,
                            booleanValue]))).every(Boolean) ? true : false;
                        }

                      function getConsumer(appName) {
                          try {
                            const consumerId = appName.split('-')[1];
                            if (!consumerId) {
                              const detail = 'Identificación de aplicación inválida';
                              const code = 'SA409';
                              errors.push({ code, detail });
                              context.set('ctx.errors', errors);
                            }
                            return consumerId;
                          } catch (exception) {
                            const detail = 'Identificación de aplicación inválida';
                            const code = 'SA409';
                            errors.push({ code, detail });
                            context.set('ctx.errors', errors);
                          }
                        }

                      function handleError(e) {
                          const detail = e.message;
                          const code = 'SA500';
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwParameterError('ParametersException');
                        }

                      function throwParameterError(errorName) {
                          const description = 'Bad Request';
                          const code = '400';
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                          context.message.statusCode = code;
                        }
                    description: >-
                      Se realiza la validación de los parámetros del query de la
                      solicitud del método.
                    version: 2.0.0
                - xslt:
                    title: xslt
                    source: |-
                      <?xml version="1.0" encoding="UTF-8"?>
                      <xsl:stylesheet version="1.0"
                          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                          xmlns:apigw="http://www.ibm.com/xmlns/datapower/2017/11/apigateway"
                          xmlns:dp="http://www.datapower.com/extensions"
                          extension-element-prefixes="dp apigw"
                          exclude-result-prefixes="dp apigw xsl">
                          
                          <xsl:template match="/">
                          
                            <xsl:variable name="certificateDetails" select="dp:get-cert-details(concat('cert:',substring-before(substring-after(dp:request-header('X-Client-Certificate'),'-----BEGIN CERTIFICATE-----'),'-----END CERTIFICATE-----')))"/>
                          
                          
                            <xsl:variable name="modulus" select="string($certificateDetails/*[local-name()='CertificateDetails']/*[local-name()='KeyValue']/*[local-name()='RSAKeyValue']/*[local-name()='Modulus'])" />
                            <xsl:variable name="exponent" select="string($certificateDetails/*[local-name()='CertificateDetails']/*[local-name()='KeyValue']/*[local-name()='RSAKeyValue']/*[local-name()='Exponent'])" />
                          
                            <apigw:set-variable name="'ctx.modulus'" value="$modulus"/>
                            <apigw:set-variable name="'ctx.exponent'" value="$exponent"/>
                                  
                          </xsl:template>
                      </xsl:stylesheet>
                    description: >-
                      Obtain Modulus and Exponent from Certificate sended via
                      Http Header
                    compile-settings: {}
                    version: 2.0.0
                    input: false
                - gatewayscript:
                    title: set-jwk
                    source: >-
                      buildJWK();


                      function buildJWK() {
                          try {
                              //Se obtienen los datos del certificado que llega en la solicitud el Modulus y el Exponent con el que se arma la llave pública
                              const modulus = context.get("ctx.modulus");
                              const exponent = context.get("ctx.exponent");
                          
                              if (!modulus) {
                                  throw new Error("Error con la lectura del modulus");
                              }

                              if (!exponent) {
                                  throw new Error("Error con la lectura del exponent");
                              }
                              
                              //Se arma el JWK que representa de la llave pública
                              const jwkPublicKey = {
                                  n: modulus,
                                  e: exponent,
                                  kty: "RSA"
                              }

                              context.set("ctx.jwk", JSON.stringify(jwkPublicKey));
                          } catch (error) {
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                      }
                    description: Asignación del JWK
                    version: 2.0.0
                - jwt-validate:
                    title: jwt-validate
                    jwt: request.headers.json-web-token
                    output-claims: ctx.claims
                    version: 2.0.0
                    iss-claim: .+
                    aud-claim: APIGateway_LAN
                    jws-jwk: ctx.jwk
                - gatewayscript:
                    title: validation-error-jwt
                    source: >-
                      validateCredentials();


                      function validateCredentials() {
                          
                          const errors = [];
                          
                          try {
                              const app = context.get('client.app.name');
                              const appName = app.trim();
                              const claims = context.get("ctx.claims");
                              const name = appName.toUpperCase().split('-');
                              const ident = name[1];
                              const iss = claims.iss;
                              const jwtTimeExpired = context.get("jwtTimeExpired");
                              const today = (new Date() / 1000) + 60;
                              const code = 'SA401';
                              let detail;
                          
                              //validate AW
                              if (iss != ident) {
                                  detail = "Invalid Credentials";
                                  errors.push({ code, detail });
                              }
                          
                              if ((claims.exp - claims.iat) > jwtTimeExpired) {
                                  detail = "Invalid Credentials time expired invalid";
                                  errors.push({ code, detail });
                              }
                          
                              if (claims.iat > today) {
                                  detail = "Invalid Credentials iat future";
                                  errors.push({ code, detail });
                              }
                          
                              if (errors.length > 0) {
                                  context.set('ctx.errors', errors);
                                  throwError({ errorName: "ParametersException", description: "Unauthorized", code: 401 })
                              }
                          
                          } catch (error) {
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description); 
                      }
                    description: Valida si hay algún error en el JWT
                    version: 2.0.0
                - gatewayscript:
                    title: jwt-generator
                    source: >-
                      buildJWT();


                      function buildJWT(){
                          try{
                              //Importa los módulos de la plataforma para manejo de JWT
                              const jwt = require('jwt');
                              const jose = require('jose');
                                      
                              //Obtiene el tiempo actual del sistema 
                              const dateTime = parseInt(new Date() / 1000)
                                      
                              //Genera payload/claims del JWT
                              const claims = {
                                  'iss': context.get("api.properties.issuer"),
                                  'sub': context.get("api.properties.sub"),
                                  'token_use': context.get("api.properties.tokenUse"),
                                  'client_id': context.get("api.properties.clientId"),
                                  'scope': context.get("api.properties.scope"),
                                  'exp': dateTime + Number.parseInt(context.get("api.properties.expTime")), // 3600 preproductivos y 120 producción
                                  'iat': dateTime
                              };
                                      
                              //Construye el nombre interno que le da la plataforma a la llave privada del TLS Profile
                              const orgName = context.get("api.org.name");
                              const tlsProfileName = context.get("api.properties.tlsProfile"); //Nombre del TLS Profile que contiene la llave privada 
                              const catalogName = context.get("api.catalog.name");
                              const privateKeyName = orgName+"_"+catalogName +"_tlsp-"+tlsProfileName+'V1.0.0-key'; //Concatena todo con los prefijos y sufijos que asigna la plataforma
                                      
                              //Construye el header para el JWT
                              const jwsHdr = jose.createJWSHeader(privateKeyName, 'RS256');
                              jwsHdr.setProtected('kid', context.get("api.properties.kid")).setProtected('typ', 'JWT');
                                      
                              //Prepara el payload/claims y header para firmar el JWT
                              const encoder = new jwt.Encoder(claims);
                              encoder.addOperation('sign', jwsHdr); 
                                      
                              //Firma el JWT y lo asigna en el header de autorización
                              encoder.encode(function (error, jwtToken) { 
                                  context.set('message.headers.Authorization', 'Bearer '+ jwtToken);
                              });
                          }catch(error){
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                      }
                    description: Generación de JWT usando un TLS Client Profile
                    version: 2.0.0
                - invoke:
                    title: invoke
                    verb: POST
                    timeout: 5
                    cache-response: protocol
                    cache-ttl: 900
                    stop-on-error:
                      - ConnectionError
                      - OperationError
                    version: 2.2.0
                    tls-profile: $(tlsProfile)
                    target-url: $(endpoint)$(api.operation.path)
                - parse:
                    title: parse
                    version: 2.1.0
                    parse-settings-reference:
                      default: apic-default-parsesettings
                - validate:
                    title: validate
                    version: 2.6.0
                    graphql-error-policy: none
                    compile-settings: {}
                    validate-against: definition
                    definition: '#/components/schemas/enrollResponse'
            - condition: ($operationID() = 'registerAcceptanceTerms')
              execute:
                - gatewayscript:
                    title: validate-request
                    source: >-
                      const errors = [];      


                      validateParameters();
                            
                      function validateParameters() {
                        try {
                          const app = context.get('client.app.name').trim();
                          const consumerId = getConsumer(app);
                          context.set('ctx.consumer', consumerId);
                            
                          const requestHeaders = context.get('request.headers');
                          const headerConstraints = {"authorization":{"in":"header","name":"authorization","required":true,"type":"string"},"ip":{"in":"header","name":"ip","required":true,"type":"string"},"device-id":{"in":"header","name":"device-id","required":true,"type":"string"},"accept":{"in":"header","name":"accept","required":true,"type":"string"},"message-id":{"in":"header","name":"message-id","required":true,"type":"string","pattern":"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"}};
                          validateRequestHeaders(headerConstraints, requestHeaders);
                          const bodyConstraints = {"requestBody":{"type":"object","properties":{"data":{"type":"object","properties":{"customer":{"type":"object","properties":{"identification":{"type":"object","properties":{"relationshipId":{"type":"string","maxLength":33,"minLength":1}},"required":["relationshipId"]}},"required":["identification"]},"termsConditionAccepted":{"type":"object","properties":{"productTermsAccepted":{"type":"object","properties":{"version":{"type":"string","maxLength":6,"minLength":1},"acceptance":{"type":"boolean"}},"required":["version","acceptance"]},"clausesCustomerAccepted":{"type":"object","properties":{"version":{"type":"string","maxLength":6,"minLength":1},"acceptance":{"type":"boolean"}},"required":["version","acceptance"]}},"required":["productTermsAccepted","clausesCustomerAccepted"]},"security":{"type":"object","properties":{"confirmId":{"type":"string","maxLength":2000,"minLength":1}},"required":["confirmId"]}},"required":["customer","termsConditionAccepted","security"]}},"required":["data"]}};
                          const getRequestBody = new Promise((resolve, reject) => {
                            context.message.body.readAsJSON((error, json) => (error) ?
                              reject(error) :
                              resolve(json));
                          });

                          const requestBodyValidation = (requestBody) => {
                            validateTags(bodyConstraints, requestBody);
                            
                            if (errors.length > 0) {
                              context.set('ctx.errors', errors);
                              throwParameterError('ParametersException');
                            }
                          }

                          getRequestBody.then(requestBodyValidation, handleError);
                          

                          if (errors.length > 0) {
                            context.set('ctx.errors', errors);
                            throwParameterError('ParametersException');
                          }

                        } catch (e) {
                          handleError(e)
                        }
                      }
                              
                      function validateRequestHeaders(constraints,
                      requestHeaders) {
                          const constraintsTags = Object.entries(constraints);
                          const validation = (constraintsTags.map((constraint) => {
                            const [constraintName, constraintValue] = constraint;
                            const tagToValidate = Object.entries(requestHeaders)
                              .find(tag => tag[0].toUpperCase() === constraintName.toUpperCase());
                            if (!tagToValidate) {
                              const detail = `Parámetro ${constraintName} es requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                              return false;
                            }
                            return validatePrimitives(constraintValue, tagToValidate);
                          })).every(Boolean) ? true : false;
                          return validation;
                        }

                      function validateTags(constraints, request) {
                          let validation;
                          const tagConstraints = Object.entries(constraints);
                          const requestTagNames = Object.keys(request);

                          tagConstraints.forEach((tagConstraint) => {
                            const [tagConstraintName, tagConstraintValue] = tagConstraint;

                            if (tagConstraintValue.properties ||
                              (tagConstraintValue.items && tagConstraintValue.items.properties)) {
                              const { required, properties } = (tagConstraintValue.properties)
                                ? tagConstraintValue
                                : tagConstraintValue.items;

                              const validTagNames = Object.keys(properties);

                              if (required) {
                                validateRequiredTags(required, requestTagNames);
                              }

                              validation = (requestTagNames.map((requestTagName) => {
                                return validateTag(validTagNames, requestTagName, properties,
                                  request[requestTagName]);

                              })).every(Boolean) ? true : false;
                            } else {
                              if (tagConstraintValue.required && !requestTagNames.includes(tagConstraintName)) {
                                const detail = `Parámetro ${tagConstraintName} requerido.`;
                                const code = 'SA400';
                                errors.push({ code, detail });
                              } else {
                                const requestTagTovalidate = Object.entries(request)
                                  .filter((recuestField) => recuestField[0] === tagConstraintName);
                                if (requestTagTovalidate) {
                                  validation = validatePrimitives(
                                    constraints[tagConstraintName],
                                    requestTagTovalidate[0]
                                  );
                                }
                              }
                            }
                          });
                          return validation;
                        }

                      function validateTag(validTagNames, requestTagName,
                      constraints, requestObject) {
                          if (!validTagNames.includes(requestTagName)) {
                            const detail = `Parámetro ${requestTagName} no es un tag válido`;
                            const code = 'SA400';
                            errors.push({ code, detail });
                            return false;
                          }
                          const tagConstraint = {};
                          if (Array.isArray(requestObject)) {
                            if (typeof requestObject[0] !== 'object') {
                              return validatePrimitives(
                                constraints[requestTagName],
                                [requestTagName, requestObject]
                              );
                            }
                            return (requestObject.map((item) => {
                              tagConstraint[requestTagName] = constraints[requestTagName];
                              return validateTags(tagConstraint, item);
                            })).every(Boolean) ? true : false;
                          }

                          if (typeof requestObject !== 'object') {
                            return validatePrimitives(
                              constraints[requestTagName],
                              [requestTagName, requestObject]
                            );
                          }
                          tagConstraint[requestTagName] = constraints[requestTagName];
                          return validateTags(tagConstraint, requestObject);
                        }

                      function validateRequiredTags(requiredTags,
                      requestTagNames) {
                          requiredTags.forEach((requiredTag) => {
                            if (!requestTagNames.includes(requiredTag)) {
                              const detail = `Parámetro ${requiredTag} requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                            }
                          });
                        }

                      function validatePrimitives(constraint, entrie) {
                          const value = entrie[1];
                          const isArray = Array.isArray(value);
                          if (isArray) {
                            if (value.length < 1) {
                              const code = 'SA400';
                              const detail = `El arreglo ${entrie[0]} debe tener por lo mennos un valor`;
                              errors.push({ code, detail });
                              return false;
                            }
                            if (constraint.items.type === 'string') {
                              return validateStringArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'number') {
                              return validateNumberArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'integer') {
                              return validateIntegerArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'boolean') {
                              return validateBooleanArray(constraint.items, entrie);
                            }
                          }
                          if (constraint.type === 'string') {
                            return validateString(constraint, entrie);
                          }
                          if (constraint.type === 'number') {
                            return validateNumber(constraint, entrie);
                          }
                          if (constraint.type === 'integer') {
                            return validateInteger(constraint, entrie);
                          }
                          if (constraint.type === 'boolean') {
                            return validateBoolean(constraint, entrie);
                          }
                        }

                      function validateString(constraint, entrie) {
                          const code = 'SA400';
                          const type = 'string';
                          const [name, value] = entrie;
                          const { minLength, maxLength, pattern } = constraint;
                          const enumConstraints = constraint.enum;
                          const validPattern = (pattern) ? new RegExp(pattern) : null;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo ${type}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (validPattern && !validPattern.test(value)) {
                            const detail = `El valor del parámetro ${name} no cumple con la expresión regular`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (minLength && value.length < minLength) {
                            const detail = `Longitud del parámetro ${name} es menor a la lógitud mínima esperada: ${minLength}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (maxLength && value.length > maxLength) {
                            const detail = `Longitud del parámetro ${name} es mayor a la lógitud máxima esperada: ${maxLength}`;
                            errors.push({ code, detail });
                            return false;
                          }

                          return true;
                        }

                      function validateStringArray(constraint, tagToValidate) {
                          const [parameterName, arrayString] = tagToValidate;
                          return (arrayString.map(stringValue =>
                            validateString(constraint, [parameterName, stringValue])))
                            .every(Boolean) ? true : false;
                        }

                      function countDigits(number) {
                          const numberString = number.toString();
                          const [integers, decimals = ''] = numberString.split('.');
                          return { integers: integers.length, decimals: decimals.length };
                        }

                      function validateNumber(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo double`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          const { integers, decimals } = countDigits(value);
                          const { integers: expectedIntegers, decimals: expectedDecimals } = countDigits(maximum);
                          const expectedDigitsValidation = integers <= expectedIntegers && decimals <= expectedDecimals;
                          if (!expectedDigitsValidation) {
                            const detail = `El valor del parámetro ${name} espera máximo ${expectedIntegers} dígitos enteros y máximo ${expectedDecimals} dígitos decimales`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateNumberArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateNumber(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateInteger(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { minimum, maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo integer`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value < minimum) {
                            const detail = `El valor del parámetro ${name} es menor que el valor permitido: ${minimum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value > maximum) {
                            const detail = `El valor del parámetro ${name} es mayor que el valor permitido: ${maximum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateIntegerArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateInteger(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateBoolean(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { type } = constraint;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo boolean`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateBooleanArray(constraint, tagToValidate) {
                          const [parameterName, arrayBoolean] = tagToValidate;
                          return (arrayBoolean.map(booleanValue => validateBoolean(constraint, [parameterName,
                            booleanValue]))).every(Boolean) ? true : false;
                        }

                      function getConsumer(appName) {
                          try {
                            const consumerId = appName.split('-')[1];
                            if (!consumerId) {
                              const detail = 'Identificación de aplicación inválida';
                              const code = 'SA409';
                              errors.push({ code, detail });
                              context.set('ctx.errors', errors);
                            }
                            return consumerId;
                          } catch (exception) {
                            const detail = 'Identificación de aplicación inválida';
                            const code = 'SA409';
                            errors.push({ code, detail });
                            context.set('ctx.errors', errors);
                          }
                        }

                      function handleError(e) {
                          const detail = e.message;
                          const code = 'SA500';
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwParameterError('ParametersException');
                        }

                      function throwParameterError(errorName) {
                          const description = 'Bad Request';
                          const code = '400';
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                          context.message.statusCode = code;
                        }
                    description: >-
                      Se realiza la validación de los parámetros del query de la
                      solicitud del método.
                    version: 2.0.0
                - gatewayscript:
                    title: jwt-generator
                    source: >-
                      buildJWT();


                      function buildJWT(){
                          try{
                              //Importa los módulos de la plataforma para manejo de JWT
                              const jwt = require('jwt');
                              const jose = require('jose');
                                      
                              //Obtiene el tiempo actual del sistema 
                              const dateTime = parseInt(new Date() / 1000)
                                      
                              //Genera payload/claims del JWT
                              const claims = {
                                  'iss': context.get("api.properties.issuer"),
                                  'sub': context.get("api.properties.sub"),
                                  'token_use': context.get("api.properties.tokenUse"),
                                  'client_id': context.get("api.properties.clientId"),
                                  'scope': context.get("api.properties.scope"),
                                  'exp': dateTime + Number.parseInt(context.get("api.properties.expTime")), // 3600 preproductivos y 120 producción
                                  'iat': dateTime
                              };
                                      
                              //Construye el nombre interno que le da la plataforma a la llave privada del TLS Profile
                              const orgName = context.get("api.org.name");
                              const tlsProfileName = context.get("api.properties.tlsProfile"); //Nombre del TLS Profile que contiene la llave privada 
                              const catalogName = context.get("api.catalog.name");
                              const privateKeyName = orgName+"_"+catalogName +"_tlsp-"+tlsProfileName+'V1.0.0-key'; //Concatena todo con los prefijos y sufijos que asigna la plataforma
                                      
                              //Construye el header para el JWT
                              const jwsHdr = jose.createJWSHeader(privateKeyName, 'RS256');
                              jwsHdr.setProtected('kid', context.get("api.properties.kid")).setProtected('typ', 'JWT');
                                      
                              //Prepara el payload/claims y header para firmar el JWT
                              const encoder = new jwt.Encoder(claims);
                              encoder.addOperation('sign', jwsHdr); 
                                      
                              //Firma el JWT y lo asigna en el header de autorización
                              encoder.encode(function (error, jwtToken) { 
                                  context.set('message.headers.Authorization', 'Bearer '+ jwtToken);
                              });
                          }catch(error){
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                      }
                    description: Generación de JWT usando un TLS Client Profile
                    version: 2.0.0
                - invoke:
                    title: invoke
                    verb: POST
                    timeout: 5
                    cache-response: protocol
                    cache-ttl: 900
                    stop-on-error:
                      - ConnectionError
                      - OperationError
                    version: 2.2.0
                    tls-profile: $(tlsProfile)
                    target-url: $(endpoint)$(api.operation.path)
                - parse:
                    title: parse
                    version: 2.1.0
                    parse-settings-reference:
                      default: apic-default-parsesettings
                - validate:
                    title: validate
                    version: 2.6.0
                    graphql-error-policy: none
                    compile-settings: {}
                    validate-against: definition
                    definition: '#/components/schemas/registerAcceptanceTermsResponse'
            - condition: ($operationID() = 'retrieveTermsConditions')
              execute:
                - gatewayscript:
                    title: validate-request
                    source: >-
                      const errors = [];      


                      validateParameters();
                            
                      function validateParameters() {
                        try {
                          const app = context.get('client.app.name').trim();
                          const consumerId = getConsumer(app);
                          context.set('ctx.consumer', consumerId);
                            
                          const requestHeaders = context.get('request.headers');
                          const headerConstraints = {"authorization":{"in":"header","name":"authorization","required":true,"type":"string"},"ip":{"in":"header","name":"ip","required":true,"type":"string"},"device-id":{"in":"header","name":"device-id","required":true,"type":"string"},"accept":{"in":"header","name":"accept","required":true,"type":"string"},"message-id":{"in":"header","name":"message-id","required":true,"type":"string","pattern":"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"}};
                          validateRequestHeaders(headerConstraints, requestHeaders);
                          const bodyConstraints = {"requestBody":{"type":"object","properties":{"data":{"type":"object","properties":{"customer":{"type":"object","properties":{"identification":{"type":"object","properties":{"relationshipId":{"type":"string","maxLength":33,"minLength":1}},"required":["relationshipId"]}},"required":["identification"]},"security":{"type":"object","properties":{"confirmId":{"type":"string","maxLength":2000,"minLength":1}},"required":["confirmId"]}},"required":["customer","security"]}},"required":["data"]}};
                          const getRequestBody = new Promise((resolve, reject) => {
                            context.message.body.readAsJSON((error, json) => (error) ?
                              reject(error) :
                              resolve(json));
                          });

                          const requestBodyValidation = (requestBody) => {
                            validateTags(bodyConstraints, requestBody);
                            
                            if (errors.length > 0) {
                              context.set('ctx.errors', errors);
                              throwParameterError('ParametersException');
                            }
                          }

                          getRequestBody.then(requestBodyValidation, handleError);
                          

                          if (errors.length > 0) {
                            context.set('ctx.errors', errors);
                            throwParameterError('ParametersException');
                          }

                        } catch (e) {
                          handleError(e)
                        }
                      }
                              
                      function validateRequestHeaders(constraints,
                      requestHeaders) {
                          const constraintsTags = Object.entries(constraints);
                          const validation = (constraintsTags.map((constraint) => {
                            const [constraintName, constraintValue] = constraint;
                            const tagToValidate = Object.entries(requestHeaders)
                              .find(tag => tag[0].toUpperCase() === constraintName.toUpperCase());
                            if (!tagToValidate) {
                              const detail = `Parámetro ${constraintName} es requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                              return false;
                            }
                            return validatePrimitives(constraintValue, tagToValidate);
                          })).every(Boolean) ? true : false;
                          return validation;
                        }

                      function validateTags(constraints, request) {
                          let validation;
                          const tagConstraints = Object.entries(constraints);
                          const requestTagNames = Object.keys(request);

                          tagConstraints.forEach((tagConstraint) => {
                            const [tagConstraintName, tagConstraintValue] = tagConstraint;

                            if (tagConstraintValue.properties ||
                              (tagConstraintValue.items && tagConstraintValue.items.properties)) {
                              const { required, properties } = (tagConstraintValue.properties)
                                ? tagConstraintValue
                                : tagConstraintValue.items;

                              const validTagNames = Object.keys(properties);

                              if (required) {
                                validateRequiredTags(required, requestTagNames);
                              }

                              validation = (requestTagNames.map((requestTagName) => {
                                return validateTag(validTagNames, requestTagName, properties,
                                  request[requestTagName]);

                              })).every(Boolean) ? true : false;
                            } else {
                              if (tagConstraintValue.required && !requestTagNames.includes(tagConstraintName)) {
                                const detail = `Parámetro ${tagConstraintName} requerido.`;
                                const code = 'SA400';
                                errors.push({ code, detail });
                              } else {
                                const requestTagTovalidate = Object.entries(request)
                                  .filter((recuestField) => recuestField[0] === tagConstraintName);
                                if (requestTagTovalidate) {
                                  validation = validatePrimitives(
                                    constraints[tagConstraintName],
                                    requestTagTovalidate[0]
                                  );
                                }
                              }
                            }
                          });
                          return validation;
                        }

                      function validateTag(validTagNames, requestTagName,
                      constraints, requestObject) {
                          if (!validTagNames.includes(requestTagName)) {
                            const detail = `Parámetro ${requestTagName} no es un tag válido`;
                            const code = 'SA400';
                            errors.push({ code, detail });
                            return false;
                          }
                          const tagConstraint = {};
                          if (Array.isArray(requestObject)) {
                            if (typeof requestObject[0] !== 'object') {
                              return validatePrimitives(
                                constraints[requestTagName],
                                [requestTagName, requestObject]
                              );
                            }
                            return (requestObject.map((item) => {
                              tagConstraint[requestTagName] = constraints[requestTagName];
                              return validateTags(tagConstraint, item);
                            })).every(Boolean) ? true : false;
                          }

                          if (typeof requestObject !== 'object') {
                            return validatePrimitives(
                              constraints[requestTagName],
                              [requestTagName, requestObject]
                            );
                          }
                          tagConstraint[requestTagName] = constraints[requestTagName];
                          return validateTags(tagConstraint, requestObject);
                        }

                      function validateRequiredTags(requiredTags,
                      requestTagNames) {
                          requiredTags.forEach((requiredTag) => {
                            if (!requestTagNames.includes(requiredTag)) {
                              const detail = `Parámetro ${requiredTag} requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                            }
                          });
                        }

                      function validatePrimitives(constraint, entrie) {
                          const value = entrie[1];
                          const isArray = Array.isArray(value);
                          if (isArray) {
                            if (value.length < 1) {
                              const code = 'SA400';
                              const detail = `El arreglo ${entrie[0]} debe tener por lo mennos un valor`;
                              errors.push({ code, detail });
                              return false;
                            }
                            if (constraint.items.type === 'string') {
                              return validateStringArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'number') {
                              return validateNumberArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'integer') {
                              return validateIntegerArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'boolean') {
                              return validateBooleanArray(constraint.items, entrie);
                            }
                          }
                          if (constraint.type === 'string') {
                            return validateString(constraint, entrie);
                          }
                          if (constraint.type === 'number') {
                            return validateNumber(constraint, entrie);
                          }
                          if (constraint.type === 'integer') {
                            return validateInteger(constraint, entrie);
                          }
                          if (constraint.type === 'boolean') {
                            return validateBoolean(constraint, entrie);
                          }
                        }

                      function validateString(constraint, entrie) {
                          const code = 'SA400';
                          const type = 'string';
                          const [name, value] = entrie;
                          const { minLength, maxLength, pattern } = constraint;
                          const enumConstraints = constraint.enum;
                          const validPattern = (pattern) ? new RegExp(pattern) : null;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo ${type}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (validPattern && !validPattern.test(value)) {
                            const detail = `El valor del parámetro ${name} no cumple con la expresión regular`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (minLength && value.length < minLength) {
                            const detail = `Longitud del parámetro ${name} es menor a la lógitud mínima esperada: ${minLength}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (maxLength && value.length > maxLength) {
                            const detail = `Longitud del parámetro ${name} es mayor a la lógitud máxima esperada: ${maxLength}`;
                            errors.push({ code, detail });
                            return false;
                          }

                          return true;
                        }

                      function validateStringArray(constraint, tagToValidate) {
                          const [parameterName, arrayString] = tagToValidate;
                          return (arrayString.map(stringValue =>
                            validateString(constraint, [parameterName, stringValue])))
                            .every(Boolean) ? true : false;
                        }

                      function countDigits(number) {
                          const numberString = number.toString();
                          const [integers, decimals = ''] = numberString.split('.');
                          return { integers: integers.length, decimals: decimals.length };
                        }

                      function validateNumber(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo double`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          const { integers, decimals } = countDigits(value);
                          const { integers: expectedIntegers, decimals: expectedDecimals } = countDigits(maximum);
                          const expectedDigitsValidation = integers <= expectedIntegers && decimals <= expectedDecimals;
                          if (!expectedDigitsValidation) {
                            const detail = `El valor del parámetro ${name} espera máximo ${expectedIntegers} dígitos enteros y máximo ${expectedDecimals} dígitos decimales`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateNumberArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateNumber(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateInteger(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { minimum, maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo integer`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value < minimum) {
                            const detail = `El valor del parámetro ${name} es menor que el valor permitido: ${minimum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value > maximum) {
                            const detail = `El valor del parámetro ${name} es mayor que el valor permitido: ${maximum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateIntegerArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateInteger(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateBoolean(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { type } = constraint;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo boolean`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateBooleanArray(constraint, tagToValidate) {
                          const [parameterName, arrayBoolean] = tagToValidate;
                          return (arrayBoolean.map(booleanValue => validateBoolean(constraint, [parameterName,
                            booleanValue]))).every(Boolean) ? true : false;
                        }

                      function getConsumer(appName) {
                          try {
                            const consumerId = appName.split('-')[1];
                            if (!consumerId) {
                              const detail = 'Identificación de aplicación inválida';
                              const code = 'SA409';
                              errors.push({ code, detail });
                              context.set('ctx.errors', errors);
                            }
                            return consumerId;
                          } catch (exception) {
                            const detail = 'Identificación de aplicación inválida';
                            const code = 'SA409';
                            errors.push({ code, detail });
                            context.set('ctx.errors', errors);
                          }
                        }

                      function handleError(e) {
                          const detail = e.message;
                          const code = 'SA500';
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwParameterError('ParametersException');
                        }

                      function throwParameterError(errorName) {
                          const description = 'Bad Request';
                          const code = '400';
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                          context.message.statusCode = code;
                        }
                    description: >-
                      Se realiza la validación de los parámetros del query de la
                      solicitud del método.
                    version: 2.0.0
                - gatewayscript:
                    title: jwt-generator
                    source: >-
                      buildJWT();


                      function buildJWT(){
                          try{
                              //Importa los módulos de la plataforma para manejo de JWT
                              const jwt = require('jwt');
                              const jose = require('jose');
                                      
                              //Obtiene el tiempo actual del sistema 
                              const dateTime = parseInt(new Date() / 1000)
                                      
                              //Genera payload/claims del JWT
                              const claims = {
                                  'iss': context.get("api.properties.issuer"),
                                  'sub': context.get("api.properties.sub"),
                                  'token_use': context.get("api.properties.tokenUse"),
                                  'client_id': context.get("api.properties.clientId"),
                                  'scope': context.get("api.properties.scope"),
                                  'exp': dateTime + Number.parseInt(context.get("api.properties.expTime")), // 3600 preproductivos y 120 producción
                                  'iat': dateTime
                              };
                                      
                              //Construye el nombre interno que le da la plataforma a la llave privada del TLS Profile
                              const orgName = context.get("api.org.name");
                              const tlsProfileName = context.get("api.properties.tlsProfile"); //Nombre del TLS Profile que contiene la llave privada 
                              const catalogName = context.get("api.catalog.name");
                              const privateKeyName = orgName+"_"+catalogName +"_tlsp-"+tlsProfileName+'V1.0.0-key'; //Concatena todo con los prefijos y sufijos que asigna la plataforma
                                      
                              //Construye el header para el JWT
                              const jwsHdr = jose.createJWSHeader(privateKeyName, 'RS256');
                              jwsHdr.setProtected('kid', context.get("api.properties.kid")).setProtected('typ', 'JWT');
                                      
                              //Prepara el payload/claims y header para firmar el JWT
                              const encoder = new jwt.Encoder(claims);
                              encoder.addOperation('sign', jwsHdr); 
                                      
                              //Firma el JWT y lo asigna en el header de autorización
                              encoder.encode(function (error, jwtToken) { 
                                  context.set('message.headers.Authorization', 'Bearer '+ jwtToken);
                              });
                          }catch(error){
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                      }
                    description: Generación de JWT usando un TLS Client Profile
                    version: 2.0.0
                - invoke:
                    title: invoke
                    verb: POST
                    timeout: 5
                    cache-response: protocol
                    cache-ttl: 900
                    stop-on-error:
                      - ConnectionError
                      - OperationError
                    version: 2.2.0
                    tls-profile: $(tlsProfile)
                    target-url: $(endpoint)$(api.operation.path)
                - parse:
                    title: parse
                    version: 2.1.0
                    parse-settings-reference:
                      default: apic-default-parsesettings
                - validate:
                    title: validate
                    version: 2.6.0
                    graphql-error-policy: none
                    compile-settings: {}
                    validate-against: definition
                    definition: '#/components/schemas/retrieveTermsConditionsResponse'
            - condition: ($operationID() = 'retrieveDetailsSubscription')
              execute:
                - gatewayscript:
                    title: validate-request
                    source: >-
                      const errors = [];      


                      validateParameters();
                            
                      function validateParameters() {
                        try {
                          const app = context.get('client.app.name').trim();
                          const consumerId = getConsumer(app);
                          context.set('ctx.consumer', consumerId);
                            
                          const requestHeaders = context.get('request.headers');
                          const headerConstraints = {"authorization":{"in":"header","name":"authorization","required":true,"type":"string"},"ip":{"in":"header","name":"ip","required":true,"type":"string"},"device-id":{"in":"header","name":"device-id","required":true,"type":"string"},"accept":{"in":"header","name":"accept","required":true,"type":"string"},"message-id":{"in":"header","name":"message-id","required":true,"type":"string","pattern":"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"}};
                          validateRequestHeaders(headerConstraints, requestHeaders);
                          const bodyConstraints = {"requestBody":{"type":"object","properties":{"data":{"type":"object","properties":{"customer":{"type":"object","properties":{"identification":{"type":"object","properties":{"relationshipId":{"type":"string","maxLength":33,"minLength":1}},"required":["relationshipId"]}},"required":["identification"]}},"required":["customer"]}},"required":["data"]}};
                          const getRequestBody = new Promise((resolve, reject) => {
                            context.message.body.readAsJSON((error, json) => (error) ?
                              reject(error) :
                              resolve(json));
                          });

                          const requestBodyValidation = (requestBody) => {
                            validateTags(bodyConstraints, requestBody);
                            
                            if (errors.length > 0) {
                              context.set('ctx.errors', errors);
                              throwParameterError('ParametersException');
                            }
                          }

                          getRequestBody.then(requestBodyValidation, handleError);
                          

                          if (errors.length > 0) {
                            context.set('ctx.errors', errors);
                            throwParameterError('ParametersException');
                          }

                        } catch (e) {
                          handleError(e)
                        }
                      }
                              
                      function validateRequestHeaders(constraints,
                      requestHeaders) {
                          const constraintsTags = Object.entries(constraints);
                          const validation = (constraintsTags.map((constraint) => {
                            const [constraintName, constraintValue] = constraint;
                            const tagToValidate = Object.entries(requestHeaders)
                              .find(tag => tag[0].toUpperCase() === constraintName.toUpperCase());
                            if (!tagToValidate) {
                              const detail = `Parámetro ${constraintName} es requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                              return false;
                            }
                            return validatePrimitives(constraintValue, tagToValidate);
                          })).every(Boolean) ? true : false;
                          return validation;
                        }

                      function validateTags(constraints, request) {
                          let validation;
                          const tagConstraints = Object.entries(constraints);
                          const requestTagNames = Object.keys(request);

                          tagConstraints.forEach((tagConstraint) => {
                            const [tagConstraintName, tagConstraintValue] = tagConstraint;

                            if (tagConstraintValue.properties ||
                              (tagConstraintValue.items && tagConstraintValue.items.properties)) {
                              const { required, properties } = (tagConstraintValue.properties)
                                ? tagConstraintValue
                                : tagConstraintValue.items;

                              const validTagNames = Object.keys(properties);

                              if (required) {
                                validateRequiredTags(required, requestTagNames);
                              }

                              validation = (requestTagNames.map((requestTagName) => {
                                return validateTag(validTagNames, requestTagName, properties,
                                  request[requestTagName]);

                              })).every(Boolean) ? true : false;
                            } else {
                              if (tagConstraintValue.required && !requestTagNames.includes(tagConstraintName)) {
                                const detail = `Parámetro ${tagConstraintName} requerido.`;
                                const code = 'SA400';
                                errors.push({ code, detail });
                              } else {
                                const requestTagTovalidate = Object.entries(request)
                                  .filter((recuestField) => recuestField[0] === tagConstraintName);
                                if (requestTagTovalidate) {
                                  validation = validatePrimitives(
                                    constraints[tagConstraintName],
                                    requestTagTovalidate[0]
                                  );
                                }
                              }
                            }
                          });
                          return validation;
                        }

                      function validateTag(validTagNames, requestTagName,
                      constraints, requestObject) {
                          if (!validTagNames.includes(requestTagName)) {
                            const detail = `Parámetro ${requestTagName} no es un tag válido`;
                            const code = 'SA400';
                            errors.push({ code, detail });
                            return false;
                          }
                          const tagConstraint = {};
                          if (Array.isArray(requestObject)) {
                            if (typeof requestObject[0] !== 'object') {
                              return validatePrimitives(
                                constraints[requestTagName],
                                [requestTagName, requestObject]
                              );
                            }
                            return (requestObject.map((item) => {
                              tagConstraint[requestTagName] = constraints[requestTagName];
                              return validateTags(tagConstraint, item);
                            })).every(Boolean) ? true : false;
                          }

                          if (typeof requestObject !== 'object') {
                            return validatePrimitives(
                              constraints[requestTagName],
                              [requestTagName, requestObject]
                            );
                          }
                          tagConstraint[requestTagName] = constraints[requestTagName];
                          return validateTags(tagConstraint, requestObject);
                        }

                      function validateRequiredTags(requiredTags,
                      requestTagNames) {
                          requiredTags.forEach((requiredTag) => {
                            if (!requestTagNames.includes(requiredTag)) {
                              const detail = `Parámetro ${requiredTag} requerido`;
                              const code = 'SA400';
                              errors.push({ code, detail });
                            }
                          });
                        }

                      function validatePrimitives(constraint, entrie) {
                          const value = entrie[1];
                          const isArray = Array.isArray(value);
                          if (isArray) {
                            if (value.length < 1) {
                              const code = 'SA400';
                              const detail = `El arreglo ${entrie[0]} debe tener por lo mennos un valor`;
                              errors.push({ code, detail });
                              return false;
                            }
                            if (constraint.items.type === 'string') {
                              return validateStringArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'number') {
                              return validateNumberArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'integer') {
                              return validateIntegerArray(constraint.items, entrie);
                            }
                            if (constraint.items.type === 'boolean') {
                              return validateBooleanArray(constraint.items, entrie);
                            }
                          }
                          if (constraint.type === 'string') {
                            return validateString(constraint, entrie);
                          }
                          if (constraint.type === 'number') {
                            return validateNumber(constraint, entrie);
                          }
                          if (constraint.type === 'integer') {
                            return validateInteger(constraint, entrie);
                          }
                          if (constraint.type === 'boolean') {
                            return validateBoolean(constraint, entrie);
                          }
                        }

                      function validateString(constraint, entrie) {
                          const code = 'SA400';
                          const type = 'string';
                          const [name, value] = entrie;
                          const { minLength, maxLength, pattern } = constraint;
                          const enumConstraints = constraint.enum;
                          const validPattern = (pattern) ? new RegExp(pattern) : null;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo ${type}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (validPattern && !validPattern.test(value)) {
                            const detail = `El valor del parámetro ${name} no cumple con la expresión regular`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (minLength && value.length < minLength) {
                            const detail = `Longitud del parámetro ${name} es menor a la lógitud mínima esperada: ${minLength}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (maxLength && value.length > maxLength) {
                            const detail = `Longitud del parámetro ${name} es mayor a la lógitud máxima esperada: ${maxLength}`;
                            errors.push({ code, detail });
                            return false;
                          }

                          return true;
                        }

                      function validateStringArray(constraint, tagToValidate) {
                          const [parameterName, arrayString] = tagToValidate;
                          return (arrayString.map(stringValue =>
                            validateString(constraint, [parameterName, stringValue])))
                            .every(Boolean) ? true : false;
                        }

                      function countDigits(number) {
                          const numberString = number.toString();
                          const [integers, decimals = ''] = numberString.split('.');
                          return { integers: integers.length, decimals: decimals.length };
                        }

                      function validateNumber(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo double`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          const { integers, decimals } = countDigits(value);
                          const { integers: expectedIntegers, decimals: expectedDecimals } = countDigits(maximum);
                          const expectedDigitsValidation = integers <= expectedIntegers && decimals <= expectedDecimals;
                          if (!expectedDigitsValidation) {
                            const detail = `El valor del parámetro ${name} espera máximo ${expectedIntegers} dígitos enteros y máximo ${expectedDecimals} dígitos decimales`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateNumberArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateNumber(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateInteger(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { minimum, maximum } = constraint;
                          const enumConstraints = constraint.enum;
                        
                          if (typeof value !== 'number') {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo integer`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (enumConstraints && !enumConstraints.includes(value)) {
                            const detail = `El valor del parámetro ${name} no hace parte de los valores válidos`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value < minimum) {
                            const detail = `El valor del parámetro ${name} es menor que el valor permitido: ${minimum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          if (value > maximum) {
                            const detail = `El valor del parámetro ${name} es mayor que el valor permitido: ${maximum}`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateIntegerArray(constraint, tagToValidate) {
                          const [parameterName, arrayNumber] = tagToValidate;
                          return (arrayNumber.map(numberValue =>
                            validateInteger(constraint, [parameterName, numberValue])))
                            .every(Boolean) ? true : false;
                        }

                      function validateBoolean(constraint, tagToValidate) {
                          const code = 'SA400';
                          const [name, value] = tagToValidate;
                          const { type } = constraint;

                          if (typeof value !== type) {
                            const detail = `El valor del parámetro ${name} se espera que sea de tipo boolean`;
                            errors.push({ code, detail });
                            return false;
                          }
                          return true;
                        }

                      function validateBooleanArray(constraint, tagToValidate) {
                          const [parameterName, arrayBoolean] = tagToValidate;
                          return (arrayBoolean.map(booleanValue => validateBoolean(constraint, [parameterName,
                            booleanValue]))).every(Boolean) ? true : false;
                        }

                      function getConsumer(appName) {
                          try {
                            const consumerId = appName.split('-')[1];
                            if (!consumerId) {
                              const detail = 'Identificación de aplicación inválida';
                              const code = 'SA409';
                              errors.push({ code, detail });
                              context.set('ctx.errors', errors);
                            }
                            return consumerId;
                          } catch (exception) {
                            const detail = 'Identificación de aplicación inválida';
                            const code = 'SA409';
                            errors.push({ code, detail });
                            context.set('ctx.errors', errors);
                          }
                        }

                      function handleError(e) {
                          const detail = e.message;
                          const code = 'SA500';
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwParameterError('ParametersException');
                        }

                      function throwParameterError(errorName) {
                          const description = 'Bad Request';
                          const code = '400';
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                          context.message.statusCode = code;
                        }
                    description: >-
                      Se realiza la validación de los parámetros del query de la
                      solicitud del método.
                    version: 2.0.0
                - gatewayscript:
                    title: jwt-generator
                    source: >-
                      buildJWT();


                      function buildJWT(){
                          try{
                              //Importa los módulos de la plataforma para manejo de JWT
                              const jwt = require('jwt');
                              const jose = require('jose');
                                      
                              //Obtiene el tiempo actual del sistema 
                              const dateTime = parseInt(new Date() / 1000)
                                      
                              //Genera payload/claims del JWT
                              const claims = {
                                  'iss': context.get("api.properties.issuer"),
                                  'sub': context.get("api.properties.sub"),
                                  'token_use': context.get("api.properties.tokenUse"),
                                  'client_id': context.get("api.properties.clientId"),
                                  'scope': context.get("api.properties.scope"),
                                  'exp': dateTime + Number.parseInt(context.get("api.properties.expTime")), // 3600 preproductivos y 120 producción
                                  'iat': dateTime
                              };
                                      
                              //Construye el nombre interno que le da la plataforma a la llave privada del TLS Profile
                              const orgName = context.get("api.org.name");
                              const tlsProfileName = context.get("api.properties.tlsProfile"); //Nombre del TLS Profile que contiene la llave privada 
                              const catalogName = context.get("api.catalog.name");
                              const privateKeyName = orgName+"_"+catalogName +"_tlsp-"+tlsProfileName+'V1.0.0-key'; //Concatena todo con los prefijos y sufijos que asigna la plataforma
                                      
                              //Construye el header para el JWT
                              const jwsHdr = jose.createJWSHeader(privateKeyName, 'RS256');
                              jwsHdr.setProtected('kid', context.get("api.properties.kid")).setProtected('typ', 'JWT');
                                      
                              //Prepara el payload/claims y header para firmar el JWT
                              const encoder = new jwt.Encoder(claims);
                              encoder.addOperation('sign', jwsHdr); 
                                      
                              //Firma el JWT y lo asigna en el header de autorización
                              encoder.encode(function (error, jwtToken) { 
                                  context.set('message.headers.Authorization', 'Bearer '+ jwtToken);
                              });
                          }catch(error){
                              handleError(error);
                          }
                      }
                          
                      function handleError(error) {
                          const detail = error.message;
                          const code = "SA500";
                          const errors = [];
                          errors.push({ code, detail });
                          context.set('ctx.errors', errors);
                          throwError({ errorName: "ParametersException" });
                      }
                          
                      function throwError({ errorName = "Default", description =
                      "Internal Error", code = 500 }) {
                          context.set("ctx.errorData", { description, code });
                          context.reject(errorName, description);
                      }
                    description: Generación de JWT usando un TLS Client Profile
                    version: 2.0.0
                - invoke:
                    title: invoke
                    verb: POST
                    timeout: 5
                    cache-response: protocol
                    cache-ttl: 900
                    stop-on-error:
                      - ConnectionError
                      - OperationError
                    version: 2.2.0
                    tls-profile: $(tlsProfile)
                    target-url: $(endpoint)$(api.operation.path)
                - parse:
                    title: parse
                    version: 2.1.0
                    parse-settings-reference:
                      default: apic-default-parsesettings
                - validate:
                    title: validate
                    version: 2.6.0
                    graphql-error-policy: none
                    compile-settings: {}
                    validate-against: definition
                    definition: '#/components/schemas/retrieveDetailsSubscriptionResponse'
            - condition: ($operationID() = 'healthOperation')
              execute: []
          version: 2.0.0
    catch:
      - errors:
          - ParametersException
        execute:
          - gatewayscript:
              title: parameters-exception
              source: |-
                const init = () => {
                  const meta = {
                      _messageId: context.get('request.headers.message-id'),
                      _requestDateTime: context.get('system.datetime') + context.get('system.timezone'),
                      _applicationId: context.get('client.app.id')
                  }
                  context.set('ctx.meta', meta);
                }

                const parametersExceptionNodeCode = () => {
                  const errors = context.get('ctx.errors');
                  const status = 400;
                  const failure = {
                    meta: context.get('ctx.meta'),
                    status,
                    title: "Bad Request",
                    errors
                  };

                  context.set('message.body', failure);
                  context.set('message.status.code', status);
                }

                init();
                parametersExceptionNodeCode();
              description: ''
              version: 2.0.0
        arrayName: execute
      - errors:
          - ConnectionError
        execute:
          - gatewayscript:
              title: connection-exception
              source: |-
                const init = () => {
                  const meta = {
                      _messageId: context.get('request.headers.message-id'),
                      _requestDateTime: context.get('system.datetime') + context.get('system.timezone'),
                      _applicationId: context.get('client.app.id')
                  }
                  context.set('ctx.meta', meta);
                }

                const connectionExceptionNodeCode = () => {
                  const status = 500;
                  const failure = {
                    meta: context.get('ctx.meta'),
                    status,
                    title: 'Connection Error',
                    errors: [
                      {
                        code: "SA".concat(status),
                        detail: 'Se ha presentado un error de conexión con el backend'
                      }
                    ]
                  };

                  context.set('message.body', failure);
                  context.set('message.status.code', status);
                }

                init();
                connectionExceptionNodeCode();
              description: ''
              version: 2.0.0
        arrayName: execute
      - errors:
          - RuntimeError
        execute:
          - gatewayscript:
              title: jwt-error
              source: |-
                const init = () => {
                  const meta = {
                      _messageId: context.get('request.headers.message-id'),
                      _requestDateTime: context.get('system.datetime') + context.get('system.timezone'),
                      _applicationId: context.get('client.app.id')
                  }
                  context.set('ctx.meta', meta);
                }

                const runtimeExceptionNodeCode = () => {
                    const statusCode = 401;
                    const failure = {
                        meta: context.get('ctx.meta'),
                        statusCode,
                        title: 'Unauthorized',
                        errors: [
                            {
                                code: 'SA'.concat(statusCode),
                                detail: context.get('jwt-validate.error-message')
                            }
                        ]
                    };
                    context.set('message.body', failure);
                    context.set('message.status.code', statusCode);
                }

                init();
                runtimeExceptionNodeCode();
              description: ''
              version: 2.0.0
        arrayName: execute
      - errors:
          - OperationError
        execute:
          - parse:
              title: parse
              version: 2.1.0
              parse-settings-reference:
                default: apic-default-parsesettings
          - validate:
              title: validate-operation-error
              version: 2.6.0
              graphql-error-policy: none
              compile-settings: {}
              validate-against: definition
              definition: '#/components/schemas/failure'
        arrayName: execute
      - errors:
          - ValidateError
        execute:
          - gatewayscript:
              title: validate-exception
              source: |-
                const init = () => {
                  const meta = {
                      _messageId: context.get('request.headers.message-id'),
                      _requestDateTime: context.get('system.datetime') + context.get('system.timezone'),
                      _applicationId: context.get('client.app.id')
                  }
                  context.set('ctx.meta', meta);
                }

                const validateExceptionNodeCode = () => {
                    const statusCode = 502;
                    const failure = {
                      meta: context.get('ctx.meta'),
                      statusCode,
                      title: 'Bad Gateway',
                      errors: [
                        {
                          code: 'SI'.concat(statusCode),
                          detail: 'Se ha presentado un error por mensaje mal formado desde el backend'
                        }
                      ]
                    };
                    context.set('message.body', failure);
                    context.set('message.status.code', statusCode);
                }

                init();
                validateExceptionNodeCode();
              description: ''
              version: 2.0.0
        arrayName: execute
      - default:
          - gatewayscript:
              title: default-exception
              source: |-
                const init = () => {
                  const meta = {
                      _messageId: context.get('request.headers.message-id'),
                      _requestDateTime: context.get('system.datetime') + context.get('system.timezone'),
                      _applicationId: context.get('client.app.id')
                  }
                  context.set('ctx.meta', meta);
                }
                  
                const defaultExceptionNodeCode = () => {
                  const statusCode = 500;
                  const failure = {
                    meta: context.get('ctx.meta'),
                    statusCode,
                    title: 'Internal Server Error',
                    errors: [
                      {
                        code: 'SA'.concat(statusCode),
                        detail: 'Se ha presentado un error inesperado'
                      }
                    ]
                  };
                  context.set('message.body', failure);
                  context.set('message.status.code', statusCode);
                }

                init();
                defaultExceptionNodeCode();
              description: ''
              version: 2.0.0
    finally:
      - gatewayscript:
          title: filter-headers
          source: >-
            const filterHeaders = () => {

            const header_meta = require('header-metadata');

            header_meta.current.headers = {
              "API-Version": context.get('api.version'),
              "RateLimit-Limit": context.get('plan.rate-limit')[0].value,
              "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
              "X-Content-Type-Options": "nosniff",
              "X-Frame-Options": "DENY",
              "Cache-Control": "private, no-cache, no-store, max-age=0, no-transform",
              "Pragma": "no-cache",
              "Expires": 0,
              "Content-Security-Policy": "default-src 'self' *.bancolombia.com"
            }

            context.set('message.headers.Content-Type', 'application/json;
            charset=utf-8;');
                
            const messageId = context.get('request.headers.message-id');
              if (messageId) {
                    context.set('message.headers.Message-Id', messageId);
              }
            }

            filterHeaders();
          description: >-
            Se filtra y configura los valores de la cabecera de respuesta del
            API.
          version: 2.0.0
x-API-Protocol:
  Protocols: HTTPS